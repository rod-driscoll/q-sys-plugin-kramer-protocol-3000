-- Q-Sys plugin for Kramer Protocol 3000
-- <https://github.com/rod-driscoll/q-sys-plugin-kramer-protocol-3000>
-- 20231106 v1.0.0 Rod Driscoll<rod@theavitgroup.com.au>

-- Information block for the plugin
PluginInfo = {
  Name = "Kramer~Protocol 3000", -- The tilde here indicates folder structure in the Shematic Elements pane
  Version = "1.0.0",
  Id = "kramer-protocol-3000.plugin.1.0.0",
  Description = "Plugin implementing Kramer Protocol 3000",
  ShowDebug = true,
  Author = "Rod Driscoll"
}

-- Define the color of the plugin object in the design
function GetColor(props)
  return { 102, 102, 102 }
end

-- The name that will initially display when dragged into a design
function GetPrettyName()
	return "Kramer Protocol 3000 " .. PluginInfo.Version
end

-- Optional function used if plugin has multiple pages
local PageNames = {"Setup","Device"} --List the pages within the plugin
function GetPages(props)
  local pages = {}
  for ix,name in ipairs(PageNames) do
    table.insert(pages, {name = PageNames[ix]})
  end
  return pages
end

-- Define User configurable Properties of the plugin
function GetProperties()
	local props = {}
  table.insert(props,{
    Name = 'Input Count',
    Type = 'integer',
    Min = 2,
    Max = 127,
    Value = 6
  })
  table.insert(props,{
    Name = 'Output Count',
    Type = 'integer',
    Min = 1,
    Max = 127,
    Value = 2
  })
  table.insert(props,{
    Name    = "Connection Type",
    Type    = "enum", 
    Choices = {"Ethernet", "Serial"},
    Value   = "Ethernet"
  })
  table.insert(props,{
    Name  = "Poll Interval",
    Type  = "integer",
    Min   = 1,
    Max   = 60, 
    Value = 3
  })
  table.insert(props,{
    Name  = "Get Device Info",
    Type  = "boolean",
    Value = true
  })
  table.insert(props,{
    Name    = "Debug Print",
    Type    = "enum",
    Choices = {"None", "Tx/Rx", "Tx", "Rx", "Function Calls", "All"},
    Value   = "None"
  })
	return props
end

-- Optional function to define pins on the plugin that are not connected to a Control
function GetPins(props)
  local pins = {}
  if props["Connection Type"].Value=="Serial" then 
    table.insert(pins,{Name="input", Direction="input", Domain="serial"})
  end
  return pins
end

-- Optional function to update available properties when properties are altered by the user
function RectifyProperties(props)
  if props.plugin_show_debug.Value == false then 
    props["Debug Print"].IsHidden = true 
  end
	return props
end

-- Defines the Controls used within the plugin
function GetControls(props)
  local ctrls = {}
  
  table.insert(ctrls, {
    Name         = "code",
    ControlType  = "Text",
    Count        = 1,
    UserPin      = true,
    PinStyle     = "Input"
  })
  
  -- Configuration Controls --
  table.insert(ctrls, {
    Name         = "IPAddress",
    ControlType  = "Text",
    Count        = 1,
    DefaultValue = "Enter an IP Address",
    UserPin      = true,
    PinStyle     = "Both"
  })
  table.insert(ctrls, {
    Name         = "TcpPort",
    ControlType  = "Knob",
    ControlUnit  = "Integer",
    DefaultValue = 5000,
    Min          = 1,
    Max          = 65535,
    Count        = 1,
    UserPin      = true,
    PinStyle     = "Both"
  })
  table.insert(ctrls, {
    Name         = "DeviceID",
    ControlType  = "Knob",
    ControlUnit  = "Integer",
    DefaultValue = 1,
    Min          = 0,
    Max          = 253,
    Count        = 1,
    UserPin      = true,
    PinStyle     = "Both"
  })
  table.insert(ctrls, {
    Name         = "Username",
    ControlType  = "Text",
    DefaultValue = "admin",
    Count        = 1,
    UserPin      = true,
    PinStyle     = "Both"
  })
  table.insert(ctrls, {
    Name         = "Password",
    ControlType  = "Text",
    DefaultValue = "",
    Count        = 1,
    UserPin      = true,
    PinStyle     = "Both"
  })
  
  -- Status Controls --
  table.insert(ctrls, {
    Name          = "Status",
    ControlType   = "Indicator",
    IndicatorType = Reflect and "StatusGP" or "Status",
    PinStyle      = "Output",
    UserPin       = true,
    Count         = 1
  })
  table.insert(ctrls, {
    Name         = "MachineNumber",
    ControlType  = "Text",
    PinStyle     = "Output",
    UserPin      = true,
    Count        = 1
  })
  table.insert(ctrls, {
    Name         = "ModelName",
    ControlType  = "Text",
    PinStyle     = "Output",
    UserPin      = true,
    Count        = 1
  })
  table.insert(ctrls, {
    Name         = "DeviceName",
    ControlType  = "Text",
    PinStyle     = "Output",
    UserPin      = true,
    Count        = 1
  })
  table.insert(ctrls, {
    Name         = "HostName",
    ControlType  = "Text",
    PinStyle     = "Output",
    UserPin      = true,
    Count        = 1
  })
  table.insert(ctrls, {
    Name         = "MACAddress",
    ControlType  = "Text",
    PinStyle     = "Output",
    UserPin      = true,
    Count        = 1,
    DefaultValue = ""
  })
  table.insert(ctrls, {
    Name         = "DeviceFirmware",
    ControlType  = "Text",
    PinStyle     = "Output",
    UserPin      = true,
    Count        = 1
  })
  table.insert(ctrls, {
    Name         = "SerialNumber",
    ControlType  = "Text",
    PinStyle     = "Output",
    UserPin      = true,
    Count        = 1
  })
  
    -- Switching Controls --
  for i = 0, props['Output Count'].Value do
        for s = 1, props['Input Count'].Value do
            table.insert(ctrls, {
                    Name = "vid-input_" .. s .. "-output_" .. i,
                    ControlType = "Button",
                    ButtonType = "Toggle",
                    PinStyle = "Both",
                    UserPin = true
                }
            )
        end
    end
  
  -- input Controls --
  --input levels are not specifically defined in protocol, however input level range is defined
  for i = 0, props['Input Count'].Value do
    table.insert(ctrls,{
      Name         = "input_" .. i .. "-level",
      ControlType  = "Knob",
      ControlUnit  = "Integer",
      DefaultValue = 0,
      Min          = -83,
      Max          = 24,
      Count        = 1,
      UserPin      = true,
      PinStyle     = "Both"
    })
    table.insert(ctrls, {
      Name         = "input_" .. i .. "-level_up",
      ControlType  = "Button",
      ButtonType   = "Momentary",
      Count        = 1,
      UserPin      = true,
      PinStyle     = "Input",
      Icon         = "Plus"
    })
    table.insert(ctrls, {
      Name         = "input_" .. i .. "-level_down",
      ControlType  = "Button",
      ButtonType   = "Momentary",
      Count        = 1,
      UserPin      = true,
      PinStyle     = "Input",
      Icon         = "Minus"
    })
    table.insert(ctrls, {
      Name         = "input_" .. i .. "-signal",
      ControlType  = "Indicator",
      IndicatorType= "Led",
      Count        = 1,
      UserPin      = true,
      PinStyle     = "Output"
    })
    table.insert(ctrls, {
      Name         = "vid-input_" .. i .. "-signal",
      ControlType  = "Indicator",
      IndicatorType= "Led",
      Count        = 1,
      UserPin      = true,
      PinStyle     = "Output"
    })
    table.insert(ctrls,{
      Name         = "input_" .. i .. "-name",
      ControlType  = "Text",
      DefaultValue = "Input " .. i,
      Count        = 1,
      UserPin      = true,
      PinStyle     = "Both"
    })
    end
  
  -- output Controls --
  for i = 0, props['Output Count'].Value do
    table.insert(ctrls,{
      Name 		= "output_" .. i .. "-level",
      ControlType  = "Knob",
      ControlUnit  = "Integer",
      DefaultValue = 0,
      Min          = -83,
      Max          = 24,
      Count        = 1,
      UserPin      = true,
      PinStyle     = "Both"
    })
    table.insert(ctrls, {
      Name         = "output_" .. i .. "-level_up",
      ControlType  = "Button",
      ButtonType   = "Trigger",
      Count        = 1,
      UserPin      = true,
      PinStyle     = "Input",
      Icon         = "Plus"
    })
    table.insert(ctrls, {
      Name         = "output_" .. i .. "-level_Down",
      ControlType  = "Button",
      ButtonType   = "Trigger",
      Count        = 1,
      UserPin      = true,
      PinStyle     = "Input",
      Icon         = "Minus"
    })
    table.insert(ctrls, {
      Name         = "output_" .. i .. "-mute",
      ControlType  = "Button",
      ButtonType   = "Toggle",
      Count        = 1,
      UserPin      = true,
      PinStyle     = "Both"
    })
    table.insert(ctrls, {
      Name         = "output_" .. i .. "-disable",
      ControlType  = "Button",
      ButtonType   = "Toggle",
      Count        = 1,
      UserPin      = true,
      PinStyle     = "Both"
    })
    table.insert(ctrls,{
      Name         = "output_" .. i .. "-name",
      ControlType  = "Text",
      DefaultValue = "Output " .. i,
      Count        = 1,
      UserPin      = true,
      PinStyle     = "Both"
    })
    end
  return ctrls
end

--Layout of controls and graphics for the plugin UI to display
function GetControlLayout(props)
  local layout = {}
  local graphics = {}
  local CurrentPage = PageNames[props["page_index"].Value]
  	
  local colors = {  
    Background  = {232,232,232},
    Transparent = {255,255,255,0},
    Text        = {24,24,24},
    Header      = {0,0,0},
    Button      = {48,32,40},
    Red         = {217,32,32},
    DarkRed     = {80,16,16},
    Green       = {32,217,32},
    OKGreen     = {48,144,48},
    Blue        = {32,32,233},
    Black       = {0,0,0},
    White       = {255,255,255},
    Gray        = {96,96,96}
  }
  
  local function label(graphic)
    for k,v in pairs({
      Type = 'Label',
      Color = { 0, 0, 0 },
      HTextAlign = 'Right',
      FontSize = 14
    }) do graphic[k] = graphic[k] or v; end;
    table.insert(graphics, graphic);
  end;
  
  local function textinput(layout)
    for k,v in pairs({
      Color = { 208, 208, 208 },
      StrokeColor = { 102, 102, 102 },
      StrokeWidth = 2,
      CornerRadius = 8,
      FontSize = 12,
      Margin = 10,
      TextBoxStyle = 'Normal'
    }) do layout[k] = layout[k] or v; end;
    return layout;
    end;
  
  layout["code"]={PrettyName="code",Style="None"}  
      
  if(CurrentPage == 'Setup') then
    -- User defines connection properties
    table.insert(graphics,{Type="GroupBox",Text="Connect",Fill=colors.Background,StrokeWidth=1,CornerRadius=4,HTextAlign="Left",Position={5,5},Size={400,120}})
    if props["Connection Type"].Value=="Ethernet" then 
      table.insert(graphics,{Type="Text",Text="IP Address",Position={15,35},Size={100,16},FontSize=14,HTextAlign="Right"})
      layout["IPAddress"] = {PrettyName="Settings~IP Address",Style="Text",Color=colors.White,Position={120,35},Size={99,16},FontSize=12}
      table.insert(graphics,{Type="Text",Text="Port",Position={15,60},Size={100,16},FontSize=14,HTextAlign="Right"})
      layout["TcpPort"] = {PrettyName="Settings~Port",Style="Text",Position={120,60},Size={99,16},FontSize=12}
      table.insert(graphics,{Type="Text",Text="(5000 default)",Position={221,60},Size={100,18},FontSize=10,HTextAlign="Left"})
      table.insert(graphics,{Type="Text",Text="Reboot",Position={315,35},Size={70,14},FontSize=12,HTextAlign="Center",Color=colors.Text})
      layout["Reboot"] = {PrettyName="Power~Reboot", Style="Button", Color=colors.Button, FontColor=colors.Red, FontSize=14, CornerRadius=2, Position={325,48}, Size={50,20} }
    else
      table.insert(graphics,{Type="Text",Text="Reset Serial",Position={5,32},Size={110,16},FontSize=14,HTextAlign="Right"})
      layout["Reset"] = {PrettyName="Settings~Reset Serial", Style="Button", Color=colors.Button, FontColor=colors.Red, FontSize=14, CornerRadius=2, Position={120,30}, Size={50,20} }
      table.insert(graphics,{Type="Text",Text="Reboot",Position={15,57},Size={100,16},FontSize=14,HTextAlign="Right"})
      layout["Reboot"] = {PrettyName="Power~Reboot", Style="Button", Color=colors.Button, FontColor=colors.Red, FontSize=14, CornerRadius=2, Position={120,55}, Size={50,20} }
    end
    table.insert(graphics,{Type="Text",Text="Device ID",Position={15,85},Size={100,16},FontSize=14,HTextAlign="Right"})
    layout["DeviceID"] = {PrettyName="Settings~Device ID Number", Style="Text", FontColor=colors.Text, Position={120,85}, Size={99,16}, FontSize=12}
  
    -- Status fields updated upon connect show model/name/serial/sw rev
    table.insert(graphics,{Type="GroupBox",Text="Status",Fill=colors.Background,StrokeWidth=1,CornerRadius=4,HTextAlign="Left",Position={5,135},Size={400,220}})
    layout["Status"] = {PrettyName="Status~Connection Status", Position={40,165}, Size={330,32}, Padding=4 }
    table.insert(graphics,{Type="Text",Text="Device Name",Position={15,212},Size={100,16},FontSize=12,HTextAlign="Right"})
    layout["DeviceName"] = {PrettyName="Status~Device Name", Style="Text", HTextAlign="Left", IsReadOnly=true, Color=colors.Transparent, StrokeWidth=0, FontSize=14, IsBold=true, FontColor=colors.Text, Position={120,211}, Size={255,16} }
    table.insert(graphics,{Type="Text",Text="Model Name",Position={15,235},Size={100,16},FontSize=12,HTextAlign="Right"})
    layout["ModelName"] = {PrettyName="Status~Model Name", Style="Text", HTextAlign="Left", IsReadOnly=true, Color=colors.Transparent, StrokeWidth=0, FontSize=14, IsBold=true, FontColor=colors.Text, Position={120,234}, Size={255,16} }
    table.insert(graphics,{Type="Text",Text="Serial Number",Position={15,258},Size={100,16},FontSize=12,HTextAlign="Right"})
    layout["SerialNumber"] = {PrettyName="Status~Serial Number", Style="Text", HTextAlign="Left", IsReadOnly=true, Color=colors.Transparent, StrokeWidth=0, FontSize=14, IsBold=true, FontColor=colors.Text, Position={120,257}, Size={255,16} }
    table.insert(graphics,{Type="Text",Text="Software Version",Position={15,281},Size={100,16},FontSize=12,HTextAlign="Right"})
    layout["DeviceFirmware"] = {PrettyName="Status~SW Version", Style="Text", HTextAlign="Left", IsReadOnly=true, Color=colors.Transparent, StrokeWidth=0, FontSize=14, IsBold=true, FontColor=colors.Text, Position={120,280}, Size={255,16} }
    table.insert(graphics,{Type="Text",Text="MAC Address",Position={15,304},Size={100,16},FontSize=12,HTextAlign="Right"})
    layout["MACAddress"] = {PrettyName="Status~MAC Address", Style="Text", HTextAlign="Left", IsReadOnly=true, Color=colors.Transparent, StrokeWidth=0, FontSize=14, IsBold=true, FontColor=colors.Text, Position={120,303}, Size={255,16} }
  
    table.insert(graphics,{Type="Text",Text=GetPrettyName(),Position={15,200},Size={380,14},FontSize=10,HTextAlign="Right", Color=colors.Gray})
  
  elseif(CurrentPage == 'Device') then 
  
    function copy(obj, seen)
      if type(obj) ~= 'table' then return obj end
      if seen and seen[obj] then return seen[obj] end
      local s = seen or {}
      local res = setmetatable({}, getmetatable(obj))
      s[obj] = res
      for k, v in pairs(obj) do res[copy(k, s)] = copy(v, s) end
      return res
    end
  
    -- start with sizes of each object
    local base_obj_ 	= { Size={ 36, 36}				, Position={0,0} } -- a gain size, and the position of the xpt fader
    local btn_ 			= { Size={base_obj_.Size[1], 16}, Position={0,0}, Style="Button" }
    -- the word "Label"
    local output_label_ = { Size={108, btn_.Size[2]}	, Position={0,0}, Type="Text", Text="Label", FontSize=11, HTextAlign="Center", WordWrap = true } 						
    -- Text entry field
    local output_name_ 	= { Size={output_label_.Size[1], base_obj_.Size[2]}, Position={0,0}, Type="Text", Style="Text", Color=colors.White, FontSize=9, HTextAlign="Center", WordWrap = true }	
    local input_name_   = { Size={base_obj_.Size[1], 54}, Position={0,0}, Type="Text", Style="Text", Color=colors.White, FontSize=9, HTextAlign="Center", WordWrap = true }
    -- number
    local output_num_ 	= { Size=base_obj_.Size			, Position={0,0}, Type="Text", FontSize=11, HTextAlign="Center" }	-- number text to be added later				
    local input_num_ 	= { Size=base_obj_.Size			, Position={0,0}, Type="Text", FontSize=11, HTextAlign="Center" }	-- number text to be added later				
    local gain_label_ 	= { Size=base_obj_.Size			, Position={0,0}, Type="Text", Text="Gain", FontSize=11, HTextAlign="Right", WordWrap = true } -- the word 'gain'
    local fader_ 		= { Size={base_obj_.Size[1], 112},Position={0,0}, Style="Fader", ShowTextbox=true }
    local ramp_ 		= { Size={ 18, 12}				, Position={0,0}, Style="Button", Color=colors.Button, FontColor=colors.White, FontSize=9, CornerRadius=0, Margin=0 } --inc, dec
    local led_ 			= { Size={ 16, 16}				, Position={0,0}, Style="Led", Margin=3, StrokeWidth=1, UnlinkOffColor=false } --StrokeColor=colors.Gray }
  
    -- Most Positions are dynamic, when initialised positions are for the first item with a 1x1 matrix 
    local tbl_				= { Position={  8,  8}, Size=nil } -- offset of the entire table
    
    -- GroupBoxes, these sizes will be altered
    local grp_output		= { Position={tbl_.Position[1]    , tbl_.Position[2]+44}, Size={354, 60}, Type="GroupBox", Text="Output", StrokeWidth=1, CornerRadius=4, HTextAlign="Left" }
    local grp_input			= { Position={tbl_.Position[1]+220, tbl_.Position[2]   }, Size={ 44,328}, Type="GroupBox", Text="Input", StrokeWidth=1, CornerRadius=4, HTextAlign="Left" }
    local grp_output_gain	= { Position={tbl_.Position[1]+272, tbl_.Position[2]   }, Size={ 82,104}, Type="GroupBox", Text="Output", StrokeWidth=1, CornerRadius=4, HTextAlign="Left" }
  
    -- build an output row from left to right to use as reference positions
    output_label_.Position[2] = grp_output.Position[2]+4 -- the word "label"
    base_obj_.Position[2] = output_label_.Position[2] + output_label_.Size[2]
    output_num_.Position = { grp_output.Position[1]+4, base_obj_.Position[2] }
    output_label_.Position[1] = output_num_.Position[1] + output_num_.Size[1] + 8
    table.insert(graphics, output_label_)
  
    output_name_.Position = { output_label_.Position[1], base_obj_.Position[2] }
    local output_xpt_label_ = copy(gain_label_)
    output_xpt_label_.Text = "Route"
    output_xpt_label_.Position = { output_label_.Position[1]+output_label_.Size[1]+8, base_obj_.Position[2] + (base_obj_.Size[2] - btn_.Size[2]) / 2 }
  
    grp_input.Position[1] = output_xpt_label_.Position[1] + output_xpt_label_.Size[1] + 8
    grp_input.Size[1] = props['Input Count'].Value * (base_obj_.Size[1] + 4) + 4				-- multiplier
    base_obj_.Position[1] = grp_input.Position[1] + 4
    grp_output_gain.Position[1] = grp_input.Position[1] + grp_input.Size[1] + 8
    grp_output.Size[1] = grp_output_gain.Position[1] + grp_output_gain.Size[1] + 8 - grp_output.Position[1]
  
    local output_mute_label_ = copy(output_label_)
    output_mute_label_.Text = "Aud/Vid Mute"
    output_mute_label_.Position = { grp_output_gain.Position[1], grp_output_gain.Position[2] + 10 }
    output_mute_label_.Size = { base_obj_.Size[1] + 8, base_obj_.Size[2] } 
    table.insert(graphics, output_mute_label_)
  
    local output_mute_ = copy(btn_)
    output_mute_.Position[1] = grp_output_gain.Position[1] + 4
    output_mute_.Color=colors.Red
    
    local output_disable_ = copy(output_mute_)
    output_disable_.Color=colors.Green
    output_disable_.Position[1] = output_mute_.Position[1]
  
    local output_gain_label_ = copy(output_mute_label_)
    output_gain_label_.Text = "Gain"
    output_gain_label_.Position[1] = output_mute_label_.Position[1] + output_mute_label_.Size[1]
    table.insert(graphics, output_gain_label_)
  
    local output_gain_ = copy(base_obj_)
    output_gain_.Style = "Knob"
    output_gain_.Position = { output_gain_label_.Position[1] + 4, base_obj_.Position[2] }
  
    -- input coordinates
    grp_output.Size[2] = output_label_.Size[2] + 4 + (props['Output Count'].Value * (base_obj_.Size[2] + 8))
    grp_output_gain.Size[1] = grp_output.Position[1] + grp_output.Size[1] - grp_output_gain.Position[1]
    grp_output_gain.Size[2] = grp_output.Position[2] + grp_output.Size[2] - grp_output_gain.Position[2]
  
    -- input labels
    local input_signal_label_ = copy(output_xpt_label_)
    input_signal_label_.Text = "Signal"
    input_signal_label_.Position[2] = grp_output.Position[2] + grp_output.Size[2] + 8
    input_signal_label_.Size[2] = led_.Size[2]
    table.insert(graphics, input_signal_label_)
    
    local input_gain_label_ = copy(output_xpt_label_)
    input_gain_label_.Text = "Gain"
    input_gain_label_.Position[2] = input_signal_label_.Position[2] + input_signal_label_.Size[2]
    input_gain_label_.Size[2] = fader_.Size[2]
    table.insert(graphics, input_gain_label_)
    
    local input_dec_ = copy(ramp_)
    input_dec_.Text = "-"
    input_dec_.String = "-=1"
    input_dec_.Position[2] = input_gain_label_.Position[2] + input_gain_label_.Size[2]
    local input_inc_ = copy(input_dec_)
    input_inc_.Text = "+"
    input_inc_.String = "+=1"
    input_inc_.Position[1] = input_dec_.Position[1] + input_dec_.Size[1]
  
    local input_label_ = copy(output_xpt_label_) -- the word 'Label'
    input_label_.Text = "Label"
    input_label_.Position[2] = input_inc_.Position[2] + input_inc_.Size[2] + 8
    input_label_.Size[2] = input_name_.Size[2]
    table.insert(graphics, input_label_)
  
    grp_input.Size[2] = input_label_.Position[2] + input_label_.Size[2] + 4
    
    table.insert(graphics, grp_output)
    table.insert(graphics, grp_input)
    table.insert(graphics, grp_output_gain)
  
    -- input items ( columns )
    --input_num_.Position = { base_obj_.Position[1], output_mute_label_.Position[2] }
    input_num_.Position = { base_obj_.Position[1], grp_input.Position[2] + 10 }
  
    --local input_mute_ = copy(btn_)
    local input_aud_signal_ = copy(led_)
    input_aud_signal_.Position = { base_obj_.Position[1], input_signal_label_.Position[2] }
    input_aud_signal_.Color=colors.Red
    --input_aud_signal_.OffColor=colors.DarkRed
  
    local input_vid_signal_ = copy(input_aud_signal_)
    input_vid_signal_.Color=colors.Green
    --input_vid_signal_.OffColor=colors.Green
    --input_vid_signal_.UnlinkOffColor=true
    --input_vid_signal_.Position[1] = input_vid_signal_.Position[1] + input_vid_signal_.Size[1]
    local input_gain_ = copy(fader_)
    input_gain_.Position = { base_obj_.Position[1], input_gain_label_.Position[2] }
    input_name_.Position = { base_obj_.Position[1], input_label_.Position[2] }
    
    -- draw outputs
    for o = 1, props['Output Count'].Value do -- For each output
      local pos_ = base_obj_.Position[2] + (o-1)*(base_obj_.Size[2] + 4)
  
      local num_ = copy(output_num_) -- number
      num_["Text"] = tostring(o)
      num_.Position[2] = pos_
      table.insert(graphics, num_)
      
      local xpt_label_ = copy(output_xpt_label_) -- the label "Route"
      xpt_label_.Position[2] = pos_
      table.insert(graphics, xpt_label_)
  
      local name_ = copy(output_name_)
      name_['PrettyName'] = "Outputs~Output ".. o .."~Output ".. o .." name"
      name_.Position[2] = pos_
      layout["output_" .. o .. "-name"] = name_
      
      local mute_ = copy(output_mute_)
      mute_['PrettyName'] = "Outputs~Output ".. o .."~Output ".. o .." mute"
      --mute_.Position[2] = pos_ + (base_obj_.Size[2] - mute_.Size[2]) / 2
      mute_.Position[2] = pos_
      layout["output_" .. o .. "-mute"] = mute_
  
      local disable_ = copy(output_disable_)
      disable_['PrettyName'] = "Outputs~Output ".. o .."~Output ".. o .." disable"
      disable_.Position[2] = pos_ + mute_.Size[2] + 2
      layout["output_" .. o .. "-disable"] = disable_
      
      local gain_ = copy(output_gain_)
      gain_['PrettyName'] = "Outputs~Output ".. o .."~Output ".. o .." level"
      gain_.Position[2] = pos_
      layout["output_" .. o .. "-level"] = gain_
    end
  
    -- draw inputs
    for i = 1, props['Input Count'].Value do -- For each input
      local pos_ = base_obj_.Position[1] + (i-1)*(base_obj_.Size[1] + 4)
  
      local num_ = copy(input_num_) -- number
      num_["Text"] = tostring(i)
      num_.Position[1] = pos_
      table.insert(graphics, num_)
  
      local name_ = copy(input_name_)
      name_['PrettyName'] = "Inputs~Input ".. i .."~Input ".. i .." name"
      name_.Position[1] = pos_
      layout["input_" .. i .. "-name"] = name_
      
      local gain_ = copy(input_gain_)
      gain_['PrettyName'] = "Inputs~Input ".. i .."~Input ".. i .." level"
      gain_.Position[1] = pos_
      layout["input_" .. i .. "-level"] = gain_
  
      local dec_ = copy(input_dec_)
      dec_['PrettyName'] = "Inputs~Input ".. i .."~Input ".. i .." down"
      dec_.Position[1] = pos_
      layout["input_" .. i .. "-level_down"] = dec_
  
      local inc_ = copy(input_inc_)
      inc_['PrettyName'] = "Inputs~Input ".. i .."~Input ".. i .." up"
      inc_.Position[1] = pos_ + inc_.Size[1]
      layout["input_" .. i .. "-level_up"] = inc_
  
      local aud_signal_ = copy(input_aud_signal_)
      aud_signal_['PrettyName'] = "Inputs~Input ".. i .."~Input ".. i .." audio signal present"
      aud_signal_.Position[1] = pos_
      layout["input_" .. i .. "-signal"] = aud_signal_
  
      local vid_signal_ = copy(input_vid_signal_)
      vid_signal_['PrettyName'] = "Inputs~Input ".. i .."~Input ".. i .." video signal present"
      vid_signal_.Position[1] = pos_ + aud_signal_.Size[1]
      layout["vid-input_" .. i .. "-signal"] = vid_signal_
  
    end
  
    -- draw crosspoints
    for o = 1, props['Output Count'].Value do -- For each output
      for i = 1, props['Input Count'].Value do -- For each input
        layout["vid-input_" .. i .. "-output_" .. o] = { 
          PrettyName = "Crosspoints~In" .. i .. " -> Out" .. o, 
          Style = "Button", 
          Legend = tostring(i), 
          Size = base_obj_.Size,
          Position = { base_obj_.Position[1] + (i-1)*(base_obj_.Size[1] + 4),  base_obj_.Position[2] + (o-1)*(base_obj_.Size[2] + 4) } }
      end
    end
  end;
  return layout, graphics
end

--Start event based logic
if Controls then
  
  local helper = require('Helpers')
  
  -- Control aliases
  Status = Controls.Status
  
  local SimulateFeedback = true
  -- Variables and flags
  DebugTx=false
  DebugRx=false
  DebugFunction=false
  DebugPrint=Properties["Debug Print"].Value	
  
  -- Timers, tables, and constants
  StatusState = { OK = 0, COMPROMISED = 1, FAULT = 2, NOTPRESENT = 3, MISSING = 4, INITIALIZING = 5 }
  Heartbeat = Timer.New()
  VolumeDebounce = Timer.New()
  PollRate = Properties["Poll Interval"].Value
  Timeout = PollRate + 10
  BufferLength = 1024
  ConnectionType = Properties["Connection Type"].Value
  DataBuffer = ""
  CommandQueue = {}
  CommandProcessing = false
  --Internal command timeout
  CommandTimeout = 5
  CommunicationTimer = Timer.New()
  TimeoutCount = 0
  
  --Hide controls that are just for pins
  --Controls["ModelNumber"].IsInvisible=true
  --Controls["PanelType"].IsInvisible=true
  
  
  	local Request = {
  		Status			={Command="", Valid=true,			Data=""},
  		AudioEmbedding	={Command="AUD-EMB",	Data=""},
  		--AudioRoute	={Command="AUD",	Data=""},
  		AudioLevel		={Command="AUD-LVL",	Data=""},
  		AudioLevelRange	={Command="AUD-LVL-RANGE",Data=""},
  		AudioSignalPresent={Command="AUD-SIGNAL",Data=""},
  		AVRoute	={Command="AV",	Data=""},
  		AutoSwitchMode	={Command="AV-SW-MODE",	Data=""},
  		AutoSwitchTimeout={Command="AV-SW-TIMEOUT",Data=""},
  		Balance		={Command="BALANCE",Data=""},
  		--Baud		={Command="BAUD",Data=""},
  		DeviceInfo		={Command="BEACON-INFO",Data=""},
  		BuildDate		={Command="BUILD-DATE",	Data=""},
  		--CopyEDIDSet		={Command="CPEDID",		Data=""},
  		HPD				={Command="DISPLAY",	Data=""},
  		DipSwitch		={Command="DPSW-STATUS",Data=""},
  		EthernetPort	={Command="ETH-PORT",	Data=""},
  		Error			={Command="ERR",		Data=""},
  		FactoryReset	={Command="FACTORY",	Data=""},
  		FPGAVersion		={Command="FPGA-VER",	Data=""},
  		HDCPMode		={Command="HDCP-MOD",	Data=""},
  		HDCPStatus		={Command="HDCP-STAT",	Data=""},
  		Help			={Command="HELP", Valid=true,		Data=""},
  		LockEDID		={Command="LOCK-EDID",	Data=""},
  		Login			={Command="LOGIN", Valid=true,		Data=""},
  		Logout			={Command="LOGOUT",		Data=""},
  		Model			={Command="MODEL",		Data=""},
  		Mute			={Command="MUTE",		Data=""},
  		HostName		={Command="NAME",		Data=""},
  		ResetName		={Command="NAME-RST",	Data=""},
  		NetworkConfig	={Command="NET-CONFIG",	Data=""},
  		DHCP			={Command="NET-DHCP",	Data=""},
  		Gateway			={Command="NET-GATE",	Data=""},
  		IPAddress		={Command="NET-IP",		Data=""},
  		MACAddress		={Command="NET-MAC",	Data=""},
  		NetMask			={Command="NET-MASK",	Data=""},
  		Password		={Command="PASS",		Data=""},
  		ProtocolVersion	={Command="PROT-VER",	Data=""},
  		Reset			={Command="RESET",		Data=""},
  		Route			={Command="ROUTE", Valid=true,		Data=""},
  		Security		={Command="SECUR",		Data=""},
  		SignalPresent	={Command="SIGNAL",		Data=""},
  		SerialNumber	={Command="SN",			Data=""},
  		Time			={Command="TIME",		Data=""},
  		TimeZone		={Command="TIME-LOC",	Data=""},
  		TimeServer		={Command="TIME-SRV",	Data=""},
  		--Uart		={Command="UART",	Data=""},
  		VGAPhase		={Command="VGA-PHASE",	Data=""},
  		DeviceFirmware ={Command="VERSION",	Data=""},
  		VideoMute		={Command="VMUTE",		Data=""},
  }
  
  -- Helper functions
  -- A function to determine common print statement scenarios for troubleshooting
  function SetupDebugPrint()
  	if DebugPrint=="Tx/Rx" then
  		DebugTx,DebugRx=true,true
  	elseif DebugPrint=="Tx" then
  		DebugTx=true
  	elseif DebugPrint=="Rx" then
  		DebugRx=true
  	elseif DebugPrint=="Function Calls" then
  		DebugFunction=true
  	elseif DebugPrint=="All" then
  		DebugTx,DebugRx,DebugFunction=true,true,true
  	end
  end
  
  -- A function to clear controls/flags/variables and clears tables
  function ClearVariables()
  	if DebugFunction then print("ClearVariables() Called") end
  	Controls["SerialNumber"].String = ""
  	Controls["DeviceFirmware"].String = ""
  	Controls["ModelName"].String = ""
  	Controls["DeviceName"].String = ""
  	Controls["MACAddress"].String = ""
  	Controls["HostName"].String = ""
  	DataBuffer = ""
  	CommandQueue = {}
  end
  
  --Reset any of the "Unavailable" data;  Will cause a momentary colision that will resolve itself the customer names the device "Unavailable"
  function ClearUnavailableData()
  	if DebugFunction then print("ClearUnavailableData() Called") end
  	-- If data was unavailable reset it; the next poll loop will test for it again
  	for i,ctrl in ipairs({ "SerialNumber", "DeviceFirmware", "ModelNumber", "ModelName", "DeviceName", "MACAddress" }) do
  		if(Controls[ctrl].String == "Unavailable")then
  			Controls[ctrl].String = ""
  		end
  	end
  end
  
  -- Update the Status control
  function ReportStatus(state,msg)
  	if DebugFunction then print("ReportStatus() Called: "..state..". "..msg) end
  	local msg=msg or ""
  	Status.Value=StatusState[state]
  	Status.String=msg
  end
  
  
  function Split(s, delimiter)
  	if DebugFunction then print("Split() Called") end
  	local result = {};
  	for match in (s..delimiter):gmatch("(.-)"..delimiter) do
  		table.insert(result, match);
  	end
  	return result;
  end
  
  --Parse a string from byte array
  function ParseString(data)
  	if DebugFunction then print("ParseString() Called") end
  	local name = ""
  	for i,byte in ipairs(data) do
  		name = name .. string.char(byte)
  	end
  	return name
  end
  
  function GetPrintableHexString(str)
  	local result_ = ""
  	for i=1, #str do
  		local c = str:sub(i,i)
  		if c:byte() > 0x1F and c:byte() < 0x7F then
  			result_ = result_..c
  		else
  			result_ = result_..string.format("\\x%02X", c:byte())
  		end
  	end
  	return result_  
  end
  
  --A debounce timer on power up avoids reporting the TCP reset that occurs as ane error
  function ClearDebounce()
  	PowerOnDebounce = false
  end
  -------------------------------------------------------------------------------
  -- Device functions
  -------------------------------------------------------------------------------
  
  --[[  Communication format
  	All commands are hex bytes of the format:
  	Header   CommandName   Constant   Parameters   Suffix
  		#     <Command>       0x20    <Data>  0x0d
  
  	Both Serial and TCP mode must contain functions:
  	Connect()
  	And a receive handler that passes data to ParseData()
  ]]
  
  -- Take a request object and queue it for sending.  Object format is of:
  --  { Command=string, Data={string} }
  function Send(cmd, sendImmediately)
  	if DebugFunction then print("DoSend("..cmd.Command..") Called") end
  	if cmd['Valid']~=nil then 
  		print(cmd.Command..' is valid')
  	end
  	local value = "#".. cmd.Command
  	if string.len(cmd.Data)>0 then value = value.." "..cmd.Data end
  	value = string.format("%s\x0d",value)
  	--local value = string.format("#%s %s%s\x0d", cmd.Command, cmd.Data or "", value) -- '#<COMMAND>? <DATA>\x0d'
  
  	--Check for if a command is already queued
  	for i, val in ipairs(CommandQueue) do
  		if(val == value)then
  			--Some Commands should be sent immediately
  			if sendImmediately then
  				--remove other copies of a command and move to head of the queue
  				table.remove(CommandQueue,i)
  				if DebugTx then print("Sending: "..GetPrintableHexString(value)) end
  				table.insert(CommandQueue,1,value)
  			end
  			return
  		end
  	end
  	--Queue the command if it wasn't found
  	table.insert(CommandQueue,value)
  	SendNextCommand()
  end
  
  --Timeout functionality
  -- Close the current and start a new connection with the next command
  -- This was included due to behaviour within the Comms Serial; may be redundant check on TCP mode
  CommunicationTimer.EventHandler = function()
  	if DebugFunction then print("CommunicationTimer Event (timeout) Called") end
  	ReportStatus("MISSING","Communication Timeout")
  	CommunicationTimer:Stop()
  	CommandProcessing = false
  	SendNextCommand()
  end 
  
  	--  Serial mode Command function  --
  if ConnectionType == "Serial" then
  	print("Serial Mode Initializing...")
  	-- Create Serial Connection
  	Comms = SerialPorts[1]
  	Baudrate, DataBits, Parity = 9600, 8, "N"
  
  	--Send the display the next command off the top of the queue
  	function SendNextCommand()
  	if DebugFunction then print("SendNextCommand("..CommandProcessing..") Called") end
  	if CommandProcessing then
  		-- Do Nothing
  	elseif #CommandQueue > 0 then
  		CommandProcessing = true
  		if DebugTx then print("Sending: "..GetPrintableHexString(CommandQueue[1])) end
  		Comms:Write( table.remove(CommandQueue,1) )
  		CommunicationTimer:Start(CommandTimeout)
  	else
  		CommunicationTimer:Stop()
  	end
  	end
  
  	function Disconnected()
  		if DebugFunction then print("Disconnected() Called") end
  		CommunicationTimer:Stop() 
  		CommandQueue = {}
  		Heartbeat:Stop()
  	end
  	
  		-- Clear old and open the socket, sending the next queued command
  	function Connect()
  		if DebugFunction then print("Connect() Called") end
  		Comms:Close()
  		Comms:Open(Baudrate, DataBits, Parity)
  	end
  
  	-- Handle events from the serial port
  	Comms.Connected = function(serialTable)
  		if DebugFunction then print("Connected handler called Called") end
  		ReportStatus("OK","")
  		Connected()
  	end
  	
  	Comms.Reconnect = function(serialTable)
  		if DebugFunction then print("Reconnect handler called Called") end
  		Connected()
  	end
  	
  	Comms.Data = function(serialTable, data)
  		ReportStatus("OK","")
  		CommunicationTimer:Stop() 
  		CommandProcessing = false
  		local msg = DataBuffer .. Comms:Read(1024)
  		DataBuffer = "" 
  		if DebugRx then 
  			if msg:len() < 50 then
  				print("Received["..#msg.."]: "..GetPrintableHexString(msg))
  			else
  				print("Received["..#msg.."]: "..msg:sub(1,50))
  			end 
  		end
  		ParseResponse(msg)
  		SendNextCommand()
  	end
  	
  	Comms.Closed = function(serialTable)
  		if DebugFunction then print("Closed handler called Called") end
  		Disconnected()
  		ReportStatus("MISSING","Connection closed")
  	end
  	
  	Comms.Error = function(serialTable, error)
  		if DebugFunction then print("Socket Error handler called Called") end
  		Disconnected()
  		ReportStatus("MISSING",error)
  	end
  	
  	Comms.Timeout = function(serialTable, error)
  		if DebugFunction then print("Socket Timeout handler called Called") end
  		Disconnected()
  		ReportStatus("MISSING","Serial Timeout")
  	end
  
  	--[[
  	Controls["Reset"].EventHandler = function()
  		if DebugFunction then print("Reset handler called Called") end
  		PowerupTimer:Stop()
  		ClearVariables()
  		Disconnected()
  		Connect()
  	end
  	]]
  	
  	--  Ethernet Command Function  --
  else
  	print("TCP Mode Initializing...")
  	--IPAddress = Controls.IPAddress
  	--Port = Controls.Port
  	-- Create Sockets
  	Comms = TcpSocket.New()
  	Comms.ReconnectTimeout = 5
  	Comms.ReadTimeout = 10  --Tested to verify 6 seconds necessary for input switches;  Appears some TV behave mroe slowly
  	Comms.WriteTimeout = 10
  
  	--Send the display the next command off the top of the queue
  	function SendNextCommand()
  		if DebugFunction then print("SendNextCommand() Called") end
  		if CommandProcessing then
  		-- Do Nothing
  		elseif #CommandQueue > 0 then
  			if not Comms.IsConnected then
  				Connect()
  			else
  				CommandProcessing = true
  				if DebugTx then print("Sending: "..GetPrintableHexString(CommandQueue[1])) end
  				Comms:Write( table.remove(CommandQueue,1) )
  			end
  		end
  		end
  	
  	function Disconnected()
  		if DebugFunction then print("Disconnected() Called") end
  		if Comms.IsConnected then
  			Comms:Disconnect()
  		end
  		CommandQueue = {}
  		Heartbeat:Stop()
  	end
  	
  	-- Clear old and open the socket
  	function Connect()
  		if DebugFunction then print("Connect() Called") end
  		if Controls.IPAddress.String ~= "Enter an IP Address" and Controls.IPAddress.String ~= "" then
  			if Comms.IsConnected then
  				Comms:Disconnect()
  			end
  			Comms:Connect(Controls.IPAddress.String, Controls.TcpPort.Value)
  		else
  			ReportStatus("MISSING","No IP Address or Port")
  		end
  	end
  		
  	-- Handle events from the socket;  Nearly identical to Serial
  	Comms.EventHandler = function(sock, evt, err)
  		if DebugFunction then print("Ethernet Socket EventHandler: "..tostring(evt)) end
  
  		if evt == TcpSocket.Events.Connected then
  			if DebugRx then print("Connected "..tostring(evt)) end
  			ReportStatus("OK","")
  			Connected()
  		elseif evt == TcpSocket.Events.Reconnect then
  		--Disconnected()
  	
  		elseif evt == TcpSocket.Events.Data then
  			ReportStatus("OK","")
  			CommandProcessing = false
  			TimeoutCount = 0
  			local line = sock:Read(BufferLength)
  			local msg = DataBuffer
  			DataBuffer = "" 
  			while (line ~= nil) do
  				msg = msg..line
  				line = sock:Read(BufferLength)
  			end 
  			if DebugRx then 
  				if msg:len() < 50 then
  					print("Received["..#msg.."]: "..GetPrintableHexString(msg))
  				else
  					print("Received["..#msg.."]: "..msg:sub(1,50))
  				end 
  			end
  			ParseResponse(msg)  
  			SendNextCommand()
  		
  		elseif evt == TcpSocket.Events.Closed then
  			if DebugRx then print("Disconnected "..tostring(evt)) end
  			Disconnected()
  			ReportStatus("MISSING","Socket closed")
  	
  		elseif evt == TcpSocket.Events.Error then
  			if DebugRx then print("Socket error "..tostring(err)) end
  			Disconnected()
  			ReportStatus("MISSING","Socket error")
  		
  		elseif evt == TcpSocket.Events.Timeout then
  			if DebugRx then print("Socket timeout error "..tostring(err)) end
  			TimeoutCount = TimeoutCount + 1
  			if TimeoutCount > 3 then
  				Disconnected()
  				ReportStatus("MISSING","Socket Timeout")
  			end
  	
  		else
  			if DebugRx then print("Socket unknown  "..tostring(err)) end
  			Disconnected()
  			ReportStatus("MISSING",err)
  		end
  	end
  
  	--Ethernet specific event handlers
  	Controls["IPAddress"].EventHandler = function()
  		if DebugFunction then print("IP Address Event Handler Called") end
  		if Controls["IPAddress"].String == "" then Controls["IPAddress"].String = "Enter an IP Address" end
  		ClearVariables()
  		Initialize()
  	end
  
  	Controls["TcpPort"].EventHandler = function()
  		if DebugFunction then print("Port Event Handler Called") end
  		ClearVariables()
  		Initialize()
  	end
  
  	Controls["DeviceID"].EventHandler = function()
  		if DebugFunction then print("DeviceID Event Handler Called") end
  		ClearVariables()
  		Initialize()
  	end
  
  end
  
  function Query(cmd)
  	Send({
  		Command = cmd.Command .. "?",
  		Data = cmd.Data
  	})
  end
  
  function PrintError(msg)
  	local codes_ = {
  		[0] = 'P3K_NO_ERROR',
  		[1] = 'ERR_PROTOCOL_SYNTAX',
  		[2] = 'ERR_COMMAND_NOT_AVAILABLE',
  		[3] = 'ERR_PARAMETER_OUT_OF_RANGE',
  		[4] = 'ERR_UNAUTHORIZED_ACCESS',
  		[5] = 'ERR_INTERNAL_FW_ERROR',
  		[6] = 'ERR_BUSY',
  		[7] = 'ERR_WRONG_CRC',
  		[8] = 'ERR_TIMEDOUT',
  		[9] = 'ERR_RESERVED',
  		[10] = 'ERR_FW_NOT_ENOUGH_SPACE',
  		[11] = 'ERR_FS_NOT_ENOUGH_SPACE',
  		[12] = 'ERR_FS_FILE_NOT_EXISTS',
  		[13] = 'ERR_FS_FILE_CANT_CREATED',
  		[14] = 'ERR_FS_FILE_CANT_OPEN',
  		[15] = 'ERR_FEATURE_NOT_SUPPORTED',
  		[16] = 'ERR_RESERVED_2',
  		[17] = 'ERR_RESERVED_3',
  		[18] = 'ERR_RESERVED_4',
  		[19] = 'ERR_RESERVED_5',
  		[20] = 'ERR_RESERVED_6',
  		[21] = 'ERR_PACKET_CRC',
  		[22] = 'ERR_PACKET_MISSED',
  		[23] = 'ERR_PACKET_SIZE',
  		[24] = 'ERR_RESERVED_7',
  		[25] = 'ERR_RESERVED_8',
  		[26] = 'ERR_RESERVED_9',
  		[27] = 'ERR_RESERVED_10',
  		[28] = 'ERR_RESERVED_11',
  		[29] = 'ERR_RESERVED_12',
  		[30] = 'ERR_EDID_CORRUPTED',
  		[31] = 'ERR_NON_LISTED',
  		[32] = 'ERR_SAME_CRC',
  		[33] = 'ERR_WRONG_MODE',
  		[34] = 'ERR_NOT_CONFIGURED'
  	}
  	if codes_[tonumber(msg)]~=nil then
  		if DebugFunction then print('ERROR: '..codes_[tonumber(msg)]) end
  	end
  end
  
  function SetRouteLayerFeedback(layer, output, input)
  	if DebugFunction then print("SetRouteLayerFeedback(layer: "..layer..", output: "..output..", index: "..input..")") end
  	--if DebugFunction then print('Handling Route: "'..msg["Data"]..'"') end
  	if output~=nil and input~=nil then
  		local in_ = tonumber(input)
  		local out_ = tonumber(output)
  		if out_~=nil and out_ <= Properties['Output Count'].Value and in_~=nil and in_ <= Properties['Input Count'].Value then
  			for i=1, Properties['Input Count'].Value do
  				Controls["vid-input_"..i.."-output_" ..output].Boolean = (in_==i) 
  			end
  		end
  	end
  end
  
  function SetRouteAllFeedback(outputs)
  	if DebugFunction then print("SetRouteAllFeedback("..table.concat(outputs)..")") end
  	for o=1, #outputs do 
  		SetRouteLayerFeedback(Layers.Video, o, outputs[o])
  	end
  end
  
  --  Device Request and Data handlers
  
  --[[ Test the device once for
  	Model Number
  	Device Name
  	Model Name
  	Serial Number
  	SW Revision
  ]]
  -- Initial data grab from device
  function GetDeviceInfo()
  	if DebugFunction then print("GetDeviceInfo() Called") end
  	if Properties["Get Device Info"].Value then
  		--Query( Request["DeviceInfo"] ) -- gets "IPAddress", "UDPPort", "TCPPort", "MACAddress", "Model", and "DeviceName" 
  		--Query( Request["NetConfig"] ) -- "DeviceInfo" (BEACON-INFO?) doesn't work
  		if(Controls["SerialNumber"].String == "") then Query( Request["SerialNumber"] ) end
  		if(Controls["DeviceFirmware"].String == "") then Query( Request["DeviceFirmware"] ) end
  		if(Controls["MACAddress"].String == "") then Query( Request["MACAddress"] ) end
  		if(Controls["ModelName"].String == "") then Query( Request["Model"] ) end
  		--QueryLevelRanges() not implemented on most devices
  	end
  end
  
  function QueryLevelRanges()
  	if DebugFunction then print("QueryLevelRanges())") end
  	for i=1, Properties['Input Count'].Value do
  		local cmd_ = {Command = Request["AudioLevelRange"].Command, Data = '0,'..i }
  		if SimulateFeedback then ParseResponse(string.format("~%02X@%s %s\x0d\x0a", Controls['DeviceID'].Value, cmd_.Command, cmd_.Data..',-83,24')) end
  		Query(cmd_)
  	end
  	for o=1, Properties['Output Count'].Value do
  		local cmd_ = {Command = Request["AudioLevelRange"].Command, Data = '1,'..o }
  		if SimulateFeedback then ParseResponse(string.format("~%02X@%s %s\x0d\x0a", Controls['DeviceID'].Value, cmd_.Command, cmd_.Data..',-83,24')) end
  		Query(cmd_)
  	end
  end
  
  local function QueryRoutes()
  	Query({Command = Request["Route"].Command, Data = Layers.Video ..',*'})
  end
  
  function Connected()
  	if DebugFunction or DebugRx then print("Connected() Called") end
  	CommunicationTimer:Stop()
  	CommandProcessing = false
  	if Controls['DeviceID'].Value==nil or tonumber(Controls['DeviceID'].Value)==0 then Send({Command = Request["Status"].Command, Data = ""}) end
  	--Send({Command = Request["Help"].Command, Data = ""})
  	Heartbeat:Start(PollRate)   
  	QueryRoutes()
  	if #CommandQueue < 1 then
  		for i = 1, Properties['Input Count'].Value do
  			Query({ Command=Request["SignalPresent"].Command, Data=tostring(i) })
  			Query({ Command=Request["AudioSignalPresent"].Command, Data=tostring(i) })
  		end
  	end
  	if Controls['HostName'  ].String==nil or Controls['HostName'  ].String:len()<1 then Query({Command = Request["HostName"].Command, Data = ""}) end
  	if Controls['MACAddress'].String==nil or Controls['MACAddress'].String:len()<1 then GetDeviceInfo() end
  	SendNextCommand()
  end
  
  --[[  Response Data parser
  	
  	All response commands are hex bytes of the format
  	Header    DeviceID   Constant   CommandName  Parameters   Suffix
  		~      nn      		@  		<Command>    <Parameter>  0x0d0x0a
  
  	Read until a header is found, then:
  	1. Define a data object
  	2. Parse the command, DeviceID, and ack into the structure
  	3. Parse the data into an array
  	4. Push the data object into a handler based on the command
  
  	Recursively call if there is more data after the suffix. Stuff incomplete messages in the buffer
  ]]
  function ParseResponse(msg)
  	local delimPos_ = msg:find("\x0d\x0a")
  	if DebugFunction then print("ParseResponse("..string.len(msg)..","..delimPos_..") Called") end
  	local valid_ = msg:len()>0 and delimPos_~=nil
  	--Message is too short, buffer the chunk and wait for more
  	if not valid_ then 
  		delimPos = delimPos or 0
  		if DebugRx then 
  			if msg:len() < 50 then 
  				print("invalid["..#msg..","..delimPos.."]: "..msg)
  			else
  				print("invalid["..#msg..","..delimPos.."]: "..msg:sub(1,50))
  			end 
  		end  
  		DataBuffer = DataBuffer .. msg
  		--Message doesn't start at begining.  Find the correct start then parse from there
  	elseif msg:byte(1) ~= string.byte('~') then
  		local i=msg:find('~') 
  		if i ~= nil then
  			ParseResponse( msg:sub(i,-1) )
  		else
  			print("Starting to parse HELP response")
  			local a=1
  			--for g in msg:gmatch('([^\x0d]+)\x0d\x0a') do -- looking for multiple lines
  			for g in msg:gmatch('([%w-]+)\x0d\x0a') do -- looking for multiple lines
  				local g = string.gsub(g, '?', '')
  				print("["..a.."] len: "..g:len()..", "..g)
  				a = a+1
  				local found_ = false
  				for r,v in pairs(Request) do
  					if v.Command==g then
  						print("setting valid flag for Request["..g.."]")
  						v["Valid"] = true
  						found_ = true
  					end 
  				end
  				if not found_ then
  					print("Request["..g.."] not supported")
  				end
  			end
  			DataBuffer = ""
  			print("Finished parsing HELP response")
  		end
  	else
  		--Pack the data for the handler
  		local m1_,m2_,m3_ = msg:match('~([^@]+)@([^ ]*) ([^\x0d]+)\x0d\x0a')  -- e.g. "~01@AV 2>1\x0D\x0A"
  		if m2_==nil then m2_ = "" end
  		if m3_==nil then m3_ = "" end
  
  		if m1_==nil then 
  			if DebugFunction then print('no command match in: '..msg) end
  			m1_,m3_ = msg:match('~([^@]+)@ERR([^\x0d]+)\x0D\x0A') 
  			m2_ = Request["Error"].Command
  		end
  		
  		local ResponseObj = { ['DeviceID']=m1_, ['Command']=m2_, ['Data']=m3_ }
  		if DebugFunction then print('DeviceID: '..m1_..', Command: "'..m2_..'", data: "'..m3_..'"') end
  		--if DebugFunction then print('cResponseObj[DeviceID]:'..ResponseObj['DeviceID']) end
  		
  		if ResponseObj['Command']:len()==0 and ResponseObj['Data']:lower() == 'ok' then
  			if DebugFunction then print('device id set: '..ResponseObj['DeviceID']) end
  			Controls['DeviceID'].Value = tonumber(ResponseObj['DeviceID'])
  		elseif Controls['DeviceID'].Value == nil then
  			if DebugFunction then print('ResponseObj[DeviceID]:'..tonumber(ResponseObj['DeviceID'])) end
  			Controls['DeviceID'].Value = tonumber(ResponseObj['DeviceID'])
  			if DebugFunction then print('device id is nil, set to "'..tostring(Controls['DeviceID'].Value)..'"') end
  		end  
  		
  		if Controls['DeviceID'].Value == tonumber(ResponseObj['DeviceID']) then
  			--if DebugFunction then print('device id "'..tostring(Controls['DeviceID'].Value)..'" matches') end
  			HandleResponse(ResponseObj)    
  		else
  			if DebugFunction then print('device id "'..ResponseObj['DeviceID']..'" does not match "'..tostring(Controls['DeviceID'].Value)..'"') end
  		end
  
  		--Re-process any remaining data
  		if delimPos_~=nil and (delimPos_+2 < msg:len()) then
  			ParseResponse( msg:sub(delimPos_+2,-1) )
  		end
  	end
  		
  end
  
  -- Handler for good data from interface
  function HandleResponse(msg)
  	if DebugFunction then print('HandleResponse('..msg.Command..') Called, data['..string.len(msg.Data)..']: "'..msg.Data..'"') end
  	
  	local vals_ = {}
  	for g in string.gmatch(msg["Data"], "[^,]+") do
  		table.insert(vals_, g)
  	end
  
  	local io_ = { ['0'] = 'Input', ['1'] = 'Output'}
  
  	--Help response (getting valid commands)
  	if msg.Command=='Device' then
  
  	--Beacon info
  	elseif msg.Command==Request["DeviceInfo"].Command then
  		if DebugFunction then 
  			if vals_[1]~=nil then print("port_id: "..vals_[1]) end
  			if vals_[2]~=nil then print("IPAddress: "..vals_[2]) end
  			if vals_[3]~=nil then print("udp_port: "..vals_[3]) end
  			if vals_[4]~=nil then print("tcp_port: "..vals_[4]) end
  			if vals_[5]~=nil then print("MACAddress: "..vals_[5]) end
  			if vals_[6]~=nil then print("ModelName: "..vals_[6]) end
  			if vals_[7]~=nil then print("DeviceName: "..vals_[7]) end
  		end
  		if vals_[2]~=nil then Controls["IPAddress"].String = vals_[2] end
  		if vals_[4]~=nil then Controls["Port"].String = vals_[4] end
  		if vals_[5]~=nil then Controls["MACAddress"].String = vals_[5] end
  		if vals_[6]~=nil then Controls["ModelName"].String = vals_[6] end
  		if vals_[7]~=nil then Controls["DeviceName"].String = vals_[7] end
  
  	--Hostname
  	elseif msg.Command==Request["HostName"].Command then
  		if DebugFunction then print("HostName: "..msg["Data"]) end
  		Controls["HostName"].String = msg["Data"]
  		Controls["DeviceName"].String = msg["Data"]
  	--Firmware
  	elseif msg.Command==Request["DeviceFirmware"].Command then
  		if DebugFunction then print("DeviceFirmware: "..msg["Data"]) end
  		Controls["DeviceFirmware"].String = msg["Data"]
  	--SW Version
  	elseif msg.Command==Request["SerialNumber"].Command then
  		if DebugFunction then print("SerialNumber: "..msg["Data"]) end
  		Controls["SerialNumber"].String = msg["Data"]
  
  	elseif msg.Command==Request["IPAddress"].Command then
  		if DebugFunction then print("IPAddress: "..msg["Data"]) end
  		Controls["IPAddress"].String = msg["Data"]
  		
  	elseif msg.Command==Request["MACAddress"].Command then
  		if DebugFunction then print("MACAddress: "..msg["Data"]) end
  		Controls["MACAddress"].String = msg["Data"]
  
  	elseif msg.Command==Request["EthernetPort"].Command then
  		if DebugFunction then print("EthernetPort: "..msg["Data"]) end
  		Controls["Port"].String = msg["Data"]
  		
  	elseif msg.Command==Request["Model"].Command then
  		if DebugFunction then print("ModelName: "..msg["Data"]) end
  		Controls["ModelName"].String = msg["Data"]
  
  
  	elseif msg.Command==Request["BuildDate"].Command then
  		if DebugFunction then print("BuildDate: "..msg["Data"]) end
  		
  	elseif msg.Command==Request["DipSwitch"].Command then
  		if DebugFunction then print("DipSwitch: "..msg["Data"]) end
  
  	elseif msg.Command==Request["FPGAVersion"].Command then
  		if DebugFunction then print("FPGAVersion: "..msg["Data"]) end
  
  	elseif msg.Command==Request["NetworkConfig"].Command then
  		if DebugFunction then print("NetworkConfig: "..msg["Data"]) end
  		if DebugFunction then 
  			if vals_[1]~=nil then print("NetworkAdaptor: "..vals_[1]) end 
  			if vals_[2]~=nil then print("IPAddress: "..vals_[2])  end
  			if vals_[3]~=nil then print("SubnetMask: "..vals_[3]) end
  			if vals_[4]~=nil then print("Gateway: "..vals_[4]) end
  			if vals_[5]~=nil then print("dns1: "..vals_[5]) end
  			if vals_[6]~=nil then print("dns2: "..vals_[6]) end
  		end
  		if vals_[2]~=nil then Controls["IPAddress"].String = vals_[2] end
  
  	elseif msg.Command==Request["DHCP"].Command then
  		if DebugFunction then print("DHCP: "..msg["Data"]) end
  		
  	elseif msg.Command==Request["Gateway"].Command then
  		if DebugFunction then print("Gateway: "..msg["Data"]) end
  		
  	elseif msg.Command==Request["NetMask"].Command then
  		if DebugFunction then print("SubnetMask: "..msg["Data"]) end
  		
  	elseif msg.Command==Request["ProtocolVersion"].Command then
  		if DebugFunction then print("ProtocolVersion: "..msg["Data"]) end
  		
  	elseif msg.Command==Request["Time"].Command then
  		if DebugFunction then print("Time: "..msg["Data"]) end
  		
  	elseif msg.Command==Request["TimeZone"].Command then
  		if DebugFunction then print("TimeZone: "..msg["Data"]) end
  		
  	elseif msg.Command==Request["TimeServer"].Command then
  		if DebugFunction then print("TimeServer: "..msg["Data"]) end
  
  	elseif msg.Command==Request["Error"].Command then
  		if DebugFunction then print("Error: "..msg["Data"]) end
  		PrintError(msg["Data"])
  
  	--Authentication
  	elseif msg.Command==Request["Login"].Command then
  		if DebugFunction then print("Username: "..msg["Data"]) end
  		Controls["Username"].String = msg["Data"]	
  
  	elseif msg.Command==Request["Password"].Command then
  		--if DebugFunction then print("Password: "..msg["Data"]) end
  		if DebugFunction then 
  			if vals_[1]~=nil then print("login_level: "..vals_[1]) end
  			if vals_[2]~=nil then print("password: "..vals_[2]) end
  		end
  		if vals_[1]~=nil then Controls["Username"].String = vals_[1] end
  		if vals_[2]~=nil then Controls["Password"].String = vals_[2] end
  
  	elseif msg.Command==Request["Security"].Command then
  		if DebugFunction then print("Security: "..msg["Data"]) end
  		--Controls["Security"].String = msg["Data"]	
  
  	elseif msg.Command==Request["Logout"].Command then
  		if DebugFunction then print("Logout: "..msg["Data"]) end
  		--if msg["Data"]:lower()=='ok'
  	
  	--Audio
  	elseif msg.Command==Request["AudioEmbedding"].Command then
  		if DebugFunction then print("Embed: "..msg["Data"]) end
  
  	elseif msg.Command==Request["AudioLevelRange"].Command then
  		if DebugFunction then print("AudioLevelRange: "..msg["Data"]) end
  		if #vals_>3 then
  			if DebugFunction then print(io_[vals_[1]]..": "..vals_[2].." min: "..vals_[3].." max: "..vals_[4]) end
  			--helper.PrintControl(Controls["input_"..vals_[2].."-level"])
  			if vals_[1] == '0' and tonumber(vals_[2]) <= Properties['Input Count'].Value then
  				Inputs = Inputs or {}
  				Inputs[tonumber(vals_[2])] = Inputs[tonumber(vals_[2])] or {}
  				Inputs[tonumber(vals_[2])].MinValue = tonumber(vals_[3])
  				Inputs[tonumber(vals_[2])].MaxValue = tonumber(vals_[4])
  				--print("[input_"..vals_[2].."-level].MinValue: "..Controls["input_"..vals_[2].."-level"].MinValue)
  				--print("[input_"..vals_[2].."-level].MaxValue: "..Controls["input_"..vals_[2].."-level"].MaxValue)
  				--Controls["input_"..vals_[2].."-level"].MaxValue = tonumber(vals_[4])
  			elseif vals_[1] == '1' and tonumber(vals_[2]) <= Properties['Output Count'].Value then
  				Outputs = Outputs or {}
  				Outputs[tonumber(vals_[2])] = Outputs[tonumber(vals_[2])] or {}
  				Outputs[tonumber(vals_[2])].MinValue = tonumber(vals_[3])
  				Outputs[tonumber(vals_[2])].MaxValue = tonumber(vals_[4])
  				--Controls["output_"..vals_[2].."-level"].MinValue = tonumber(vals_[3])
  				--Controls["output_"..vals_[2].."-level"].MaxValue = tonumber(vals_[4])
  			end
  		end
  
  	elseif msg.Command==Request["AutoSwitchMode"].Command then
  		if DebugFunction then print("AutoSwitchMode: "..msg["Data"]) end
  
  	elseif msg.Command==Request["AutoSwitchTimeout"].Command then
  		if DebugFunction then print("AutoSwitchTimeout: "..msg["Data"]) end
  		
  	elseif msg.Command==Request["AudioSignalPresent"].Command then
  		if DebugFunction then print("AudioSignalPresent: "..msg["Data"]) end
  		if DebugFunction and #vals_>1 then 
  			print("aud-input_"..vals_[1].."-signal: "..vals_[2]) 
  		end
  		if #vals_>1 and tonumber(vals_[1]) <= Properties['Output Count'].Value then
  			--Controls["input_"..vals_[1].."-signal"].Boolean = (vals_[2]=='1')
  			Controls["input_"..vals_[1].."-signal"].Boolean = true
  		end
  		
  	elseif msg.Command==Request["AudioLevel"].Command then
  		if DebugFunction then print("AudioLevel: "..msg["Data"]) end
  		local layerName_ = vals_[1]=="0" and "input" or "output"
  		if DebugFunction and #vals_>2 then 
  			print(layerName_.."_"..vals_[2].."-level: "..vals_[3]) 
  		end
  		if #vals_>2 then
  			Controls[layerName_.."_"..vals_[2].."-level"].Value = tonumber(vals_[3]) 
  		end
  	
  	--Video
  	elseif msg.Command==Request["SignalPresent"].Command then
  		if DebugFunction then print("SignalPresent: "..msg["Data"]) end
  		if DebugFunction and #vals_>1 then 
  			print("vid-input_"..vals_[1].."-signal: "..vals_[2]) 
  		end
  		if #vals_>1 and tonumber(vals_[1]) <= Properties['Output Count'].Value then
  			Controls["vid-input_"..vals_[1].."-signal"].Boolean = (vals_[2]=='1') 
  		end
  
  	elseif msg.Command==Request["HPD"].Command then
  		if DebugFunction then print("HPD: "..msg["Data"]) end
  
  	elseif msg.Command==Request["HDCPMode"].Command then
  		if DebugFunction then print("HDCPMode: "..msg["Data"]) end
  
  	elseif msg.Command==Request["HDCPStatus"].Command then
  		if DebugFunction then print("HDCPStatus: "..msg["Data"]) end
  
  	elseif msg.Command==Request["LockEDID"].Command then
  		if DebugFunction then print("LockEDID: "..msg["Data"]) end
  
  	elseif msg.Command==Request["VGAPhase"].Command then
  		if DebugFunction then print("VGAPhase: "..msg["Data"]) end
  
  	elseif msg.Command==Request["Mute"].Command then
  		if DebugFunction then print("Mute: "..msg["Data"]) end 
  		if DebugFunction and #vals_>1 then 
  			print("output: "..vals_[1].." mute: "..vals_[2]) 
  		end
  		if #vals_>1 and tonumber(vals_[1]) <= Properties['Output Count'].Value then
  			Controls["output_"..vals_[1].."-mute"].Boolean = (vals_[2]=="1") 
  		end
  
  	elseif msg.Command==Request["VideoMute"].Command then
  		if DebugFunction then print("VideoMute: "..msg["Data"]) end
  		if DebugFunction and #vals_>1 then 
  			print("output: "..vals_[1].." video mute: "..vals_[2]) 
  		end
  		if #vals_>1 and tonumber(vals_[1]) <= Properties['Output Count'].Value then
  			Controls["output_"..vals_[1].."-disable"].Boolean = (vals_[2]=="1") --0:disabled, 1:enabled, 2:blank(not all models)
  		end
  
  	elseif msg.Command==Request["Route"].Command then 
  		if #vals_==3 then SetRouteLayerFeedback(vals_[1], vals_[2], vals_[3])
  		else SetRouteAllFeedback(vals_) end
  
  	elseif msg.Command==Request["AVRoute"].Command then -- "AV 2>1"
  		local i,o = string.match(msg["Data"], "(%d+)>(%d+)")
  		SetRouteLayerFeedback(Layers.Video, o, i)
  
  	else
  			print("Response not handled")
  	end
  
  end
  -------------------------------------------------------------------------------
  -- Device routing functions
  -------------------------------------------------------------------------------
  local function SetRoute(layer, dest, src, state)
  	if(state == 0) then
  		dest = "x"
  		if DebugFunction then print("Disconnecting layer " .. layer .. " src from dest " .. dest) end
  	else
  		if DebugFunction then print("Send layer " .. layer .. " from src " .. src .. " to dest " .. dest) end
  	end
  	if dest == 0 then dest = '*' end
  	local cmd_ = Request["Route"]
  	cmd_.Data = layer ..','..dest..','.. src
  	Send(cmd_)
  	if SimulateFeedback then ParseResponse(string.format("~%02X@%s %s\x0d\x0a", Controls['DeviceID'].Value, cmd_.Command, cmd_.Data)) end
  end
  
  local function SetInputLevel(index, value)
  	if DebugFunction then print("Set input " .. index .. " level to " .. value) end
  	local cmd_ = Request["AudioLevel"]
  	local value_ = tonumber(value)==nil and value or math.floor(value)
  	cmd_.Data = '0' ..','..index..','.. value
  	Send(cmd_)
  	--if SimulateFeedback and tonumber(value)~=nil then ParseResponse(string.format("~%02X@%s %s\x0d\x0a", Controls['DeviceID'].Value, cmd_.Command, cmd_.Data)) end
  end
  
  local function SetOutputLevel(index, value)
  	if DebugFunction then print("Set output " .. index .. " level to " .. value) end
  	local cmd_ = Request["AudioLevel"]
  	cmd_.Data = '1' ..','..index..','.. math.floor(value)
  	Send(cmd_)
  	--if SimulateFeedback and tonumber(value)~=nil then ParseResponse(string.format("~%02X@%s %s\x0d\x0a", Controls['DeviceID'].Value, cmd_.Command, cmd_.Data)) end
  end
  
  local function SetOutputMute(index, value)
  	if DebugFunction then print("Set output " .. index .. " mute to " .. tostring(value)) end
  	local cmd_ = Request["Mute"]
  	cmd_.Data = index..','.. (value and '1' or '0')
  	Send(cmd_)
  	--if SimulateFeedback then ParseResponse(string.format("~%02X@%s %s\x0d\x0a", Controls['DeviceID'].Value, cmd_.Command, cmd_.Data)) end
  end
  
  local function SetOutputDisable(index, value)
  	if DebugFunction then print("Set output " .. index .. " video mute to " .. tostring(value)) end
  	local cmd_ = Request["VideoMute"]
  	cmd_.Data = index..','.. (value and '1' or '0') -- 0:disabled, 1:enabled, 2:blank(not all models)
  	Send(cmd_)
  	--if SimulateFeedback then ParseResponse(string.format("~%02X@%s %s\x0d\x0a", Controls['DeviceID'].Value, cmd_.Command, cmd_.Data)) end
  end
  
  -------------------------------------------------------------------------------
  -- Initialize
  -------------------------------------------------------------------------------	
  local TestHelpResponse = [[~01@Device available protocol 3000 commands:\x0d\x0a
  	AUD?\x0d\x0a
  	AUD\x0d\x0a
  	BALANCE?\x0d\x0a
  	BALANCE\x0d\x0a
  	BAUD?\x0d\x0a
  	BAUD\x0d\x0a
  	UART?\x0d\x0a
  	UART\x0d\x0a
  	BUILD-DATE?\x0d\x0a
  	CPEDID\x0d\x0a
  	DISPLAY?\x0d\x0a
  	ETH-PORT?\x0d\x0a
  	ETH-PORT\x0d\x0a
  	FACTORY\x0d\x0a
  	GEDID\x0d\x0a
  	HELP\x0d\x0a
  	INFO-PRST?\x0d\x0a
  	INFO-IO?\x0d\x0a
  	IDV\x0d\x0a
  	LOCK-FP?\x0d\x0a
  	LOCK-FP\x0d\x0a
  	LDEDID\x0d\x0a
  	MODEL?\x0d\x0a
  	MUTE?\x0d\x0a
  	MUTE\x0d\x0a
  	NET-MASK?\x0d\x0a
  	NET-MASK\x0d\x0a
  	NET-DHCP?\x0d\x0a
  	NET-DHCP\x0d\x0a
  	NET-GATE?\x0d\x0a
  	NET-GATE\x0d\x0a
  	NET-MAC?\x0d\x0a
  	NET-IP?\x0d\x0a
  	NET-IP\x0d\x0a
  	PROT-VER?\x0d\x0a
  	PRST-AUD?\x0d\x0a
  	PRST-LST?\x0d\x0a
  	PRST-VID?\x0d\x0a
  	PRST-STO\x0d\x0a
  	PRST-RCL\x0d\x0a
  	RESET\x0d\x0a
  	SIGNAL?\x0d\x0a
  	SN?\x0d\x0a
  	SIG-TYPE?\x0d\x0a
  	VERSION?\x0d\x0a
  	VOLUME?\x0d\x0a
  	VOLUME\x0d\x0a
  	AUD-LVL?\x0d\x0a
  	AUD-LVL\x0d\x0a
  	VID?\x0d\x0a
  	VID\x0d\x0a
  	HDCP-STAT?\x0d\x0a
  	HDCP-MOD?\x0d\x0a
  	HDCP-MOD\x0d\x0a
  	MTX-MODE?\x0d\x0a
  	MTX-MODE\x0d\x0a
  	AV-SW-TIMEOUT?\x0d\x0a
  	AV-SW-TIMEOUT\x0d\x0a
  	VMUTE?\x0d\x0a
  	VMUTE\x0d\x0a
  	PRIORITY?\x0d\x0a
  	PRIORITY\x0d\x0a
  	AV-SW-MODE?\x0d\x0a
  	AV-SW-MODE\x0d\x0a
  	DPSW-STATUS?\x0d\x0a
  	FPGA-VER?\x0d\x0a
  	LABEL?\x0d\x0a
  	LABEL\x0d\x0a
  	NAME?\x0d\x0a
  	NAME\x0d\x0a
  	NAME-RST\x0d\x0a
  	VID-PATTERN?\x0d\x0a
  	VID-PATTERN\x0d\x0a
  	LOGIN?\x0d\x0a
  	LOGIN\x0d\x0a
  	LOGOUT\x0d\x0a
  	PASS?\x0d\x0a
  	PASS\x0d\x0a
  	SECUR?\x0d\x0a
  	SECUR\x0d\x0a
  	AFV?\x0d\x0a
  	AFV\x0d\x0a
  	AV\x0d\x0a
  	SET-IN-CAP?\x0d\x0a
  	SET-IN-CAP\x0d\x0a
  	PROG-ACTION?\x0d\x0a
  	PROG-ACTION\x0d\x0a
  	REMOTE-INFO?\x0d\x0a
  	TUNNEL-CTRL\x0d\x0a
  	LOAD\x0d\x0a
  	DIR\x0d\x0a]]
  
  function TestFeedbacks()
  --[[
  	local cmd_ = Request["SignalPresent"]
  	cmd_.Data = '1,1'
  	ParseResponse(string.format("~%02X@%s %s\x0d\x0a", Controls['DeviceID'].Value, cmd_.Command, cmd_.Data))
  
  	cmd_ = Request["AudioSignalPresent"]
  	cmd_.Data = '2,1'
  	ParseResponse(string.format("~%02X@%s %s\x0d\x0a", Controls['DeviceID'].Value, cmd_.Command, cmd_.Data))
  ]]
  	--~01@Device available protocol 3000 commands:\x0d\x0a
  	--cmd_= { Command = 'Device', Data = 'available protocol 3000 commands:' }
  	--TestHelpResponse = string.gsub(TestHelpResponse, [[\x0d\x0a]], "\x0d\x0a")
  	--print(TestHelpResponse:len())
  	ParseResponse(TestHelpResponse)
  end
  
  function Initialize()
  	if DebugFunction then print("Initialize() Called: "..GetPrettyName()) end
  	--helper.TablePrint(Controls, 1)
  
  	Layers = {
  		Video = 1,
  		Audio = 2,
  		Data  = 3,
  		IR    = 4,
  		USB   = 5
  	}
  
  	--helper.TablePrint(Properties, 1)
  	if(Properties['Output Count'].Value > 0 and Properties['Input Count'].Value > 0) then
  		for o = 0, Properties['Output Count'].Value do
  			for i = 1, Properties['Input Count'].Value do
  				-- Crosspoint EventHandlers
  				Controls["vid-input_" .. i .. "-output_" .. o].EventHandler = function(ctl) 
  					if DebugFunction then print("vid-input_" .. i .. "-output_" .. o .. " pressed") end
  					SetRoute(Layers.Video, o, i, ctl.Value)
  					if(o == 0) then ctl.Value = 0 end -- let the individual output buttons track state
  				end
  			end
  			
  			-- Output EventHandlers
  			Controls["output_".. o .."-mute"].EventHandler = function(ctl)
  				if DebugFunction then print("output_".. o .."-mute pressed, Value: "..tostring(ctl.Value>0)) end
  				if o>0 then SetOutputMute(o, (ctl.Value>0)) end
  			end
  
  			Controls["output_".. o .."-disable"].EventHandler = function(ctl)
  				if DebugFunction then print("output_".. o .."-disable pressed, Value: "..tostring(ctl.Value>0)) end
  				if o>0 then SetOutputDisable(o, (ctl.Value>0)) end
  			end
  
  			Controls["output_".. o .."-level"].EventHandler = function(ctl)
  				if DebugFunction then print("output_".. o .."-level pressed, Value: "..ctl.Value) end
  				if o>0 then SetOutputLevel(o, ctl.Value) end
  			end
  
  		end
  		
  		-- Input EventHandlers
  		for i = 1, Properties['Input Count'].Value do
  
  			Controls["input_".. i .."-level"].EventHandler = function(ctl)
  				if DebugFunction then print("input_".. i .."-level pressed, Value: "..ctl.Value) end
  				Controls["input_".. i .."-level"].RampTime = 0
  				SetInputLevel(i, ctl.Value)
  			end
  
  			Controls["input_".. i .."-level_up"].EventHandler = function(ctl)
  				local state_ = ctl.Boolean and "pressed" or "released"
  				if DebugFunction then print("input_".. i .."-level_up "..state_..", MaxValue: "..Controls["input_".. i .."-level"].MaxValue) end
  				if ctl.Boolean then
  					SetInputLevel(i, "++")
  					Controls["input_".. i .."-level"].RampTime = 5
  					Controls["input_".. i .."-level"].Value = Inputs[i].MaxValue
  					--SetInputLevel(i, Inputs[i].MaxValue)
  				else
  					Controls["input_".. i .."-level"].RampTime = 0
  					Controls["input_".. i .."-level"].Value = Controls["input_".. i .."-level"].Value -- need to do this or the ramp won't stopy
  					SetInputLevel(i, Controls["input_".. i .."-level"].Value)
  					--SetInputLevel(i, Controls["input_".. i .."-level"].Value)
  				end
  			end
  
  			Controls["input_".. i .."-level_down"].EventHandler = function(ctl)
  				local state_ = ctl.Boolean and "pressed" or "released"
  				if DebugFunction then print("input_".. i .."-level_down "..state_) end
  				if ctl.Boolean then
  					SetInputLevel(i, "--")
  					Controls["input_".. i .."-level"].RampTime = 5
  					Controls["input_".. i .."-level"].Value = Inputs[i].MinValue
  					--SetInputLevel(i, Controls["input_".. i .."-level"].MinValue)
  					--SetInputLevel(i, Inputs[i].MinValue)
  				else
  					Controls["input_".. i .."-level"].RampTime = 0
  					Controls["input_".. i .."-level"].Value = Controls["input_".. i .."-level"].Value -- need to do this or the ramp won't stopy
  					SetInputLevel(i, Controls["input_".. i .."-level"].Value)
  					--SetInputLevel(i, Controls["input_".. i .."-level"].Value)
  				end
  			end
  		end
  	end
  
  	Disconnected()
  	Connect()
  	--TestFeedbacks()
  	--Heartbeat:Start(PollRate)
  end
  
  -- Timer EventHandlers  --
  Heartbeat.EventHandler = function()
  	if DebugFunction then print("Heartbeat Event Handler Called - CommandQueue size: "..#CommandQueue) end
  	if #CommandQueue < 1 then
  		for i = 1, Properties['Input Count'].Value do
  			Query({ Command=Request["SignalPresent"].Command, Data=tostring(i) })
  			Query({ Command=Request["AudioSignalPresent"].Command, Data=tostring(i) })
  		end
  	end
  end
  
  SetupDebugPrint()
  Initialize()
end
