-- Q-Sys plugin for Kramer Protocol 3000
-- <https://github.com/rod-driscoll/q-sys-plugin-kramer-protocol-3000>
-- 20231106 v1.0.0 Rod Driscoll<rod@theavitgroup.com.au>

-- Information block for the plugin
PluginInfo = {
  Name = "Kramer~Protocol 3000", -- The tilde here indicates folder structure in the Shematic Elements pane
  Version = "1.0.0",
  Id = "kramer-protocol-3000.plugin.1.0.0",
  Description = "Plugin implementing Kramer Protocol 3000",
  ShowDebug = true,
  Author = "Rod Driscoll"
}

-- Define the color of the plugin object in the design
function GetColor(props)
  return { 102, 102, 102 }
end

-- The name that will initially display when dragged into a design
function GetPrettyName()
	return "Kramer Protocol 3000 " .. PluginInfo.Version
end

-- Optional function used if plugin has multiple pages
local PageNames = {"Setup","Matrix","Utilities"} --List the pages within the plugin
function GetPages(props)
  local pages = {}
  for ix,name in ipairs(PageNames) do
    table.insert(pages, {name = PageNames[ix]})
  end
  return pages
end

-- Define User configurable Properties of the plugin
function GetProperties()
	local props = {}
  table.insert(props,{
    Name = 'Model',
    Type    = "enum", 
    Choices = {"VS series", "Other"},
    Value   = "Other"
  })
  table.insert(props,{
    Name = 'Input Count',
    Type = 'integer',
    Min = 2,
    Max = 127,
    Value = 6
  })
  table.insert(props,{
    Name = 'Output Count',
    Type = 'integer',
    Min = 1,
    Max = 127,
    Value = 2
  })
  table.insert(props,{
    Name    = "Connection Type",
    Type    = "enum", 
    Choices = {"Ethernet", "Serial"},
    Value   = "Ethernet"
  })
  table.insert(props,{
    Name  = "Poll Interval",
    Type  = "integer",
    Min   = 1,
    Max   = 60, 
    Value = 10
  })
  table.insert(props,{
    Name  = "Get Device Info",
    Type  = "boolean",
    Value = true
  })
  table.insert(props,{
    Name    = "Debug Print",
    Type    = "enum",
    Choices = {"None", "Tx/Rx", "Tx", "Rx", "Function Calls", "All"},
    Value   = "None"
  })
	return props
end

-- Optional function to define pins on the plugin that are not connected to a Control
function GetPins(props)
  local pins = {}
  if props["Connection Type"].Value=="Serial" then 
    table.insert(pins,{Name="input", Direction="input", Domain="serial"})
  end
  return pins
end

-- Optional function to update available properties when properties are altered by the user
function RectifyProperties(props)
  if props.plugin_show_debug.Value == false then 
    props["Debug Print"].IsHidden = true 
  end
	return props
end

-- Defines the Controls used within the plugin
function GetControls(props)
  local ctrls = {}
  
  table.insert(ctrls, {
    Name         = "code",
    ControlType  = "Text",
    Count        = 1,
    UserPin      = true,
    PinStyle     = "Input"
  })
  
  -- Configuration Controls --
  table.insert(ctrls, {
    Name         = "IPAddress",
    ControlType  = "Text",
    Count        = 1,
    DefaultValue = "Enter an IP Address",
    UserPin      = true,
    PinStyle     = "Both"
  })
  table.insert(ctrls, {
    Name         = "TcpPort",
    ControlType  = "Knob",
    ControlUnit  = "Integer",
    DefaultValue = 5000,
    Min          = 1,
    Max          = 65535,
    Count        = 1,
    UserPin      = true,
    PinStyle     = "Both"
  })
  table.insert(ctrls, {
    Name         = "DeviceID",
    ControlType  = "Knob",
    ControlUnit  = "Integer",
    DefaultValue = 1,
    Min          = 0,
    Max          = 253,
    Count        = 1,
    UserPin      = true,
    PinStyle     = "Both"
  })
  table.insert(ctrls, {
    Name         = "Username",
    ControlType  = "Text",
    DefaultValue = "admin",
    Count        = 1,
    UserPin      = true,
    PinStyle     = "Both"
  })
  table.insert(ctrls, {
    Name         = "Password",
    ControlType  = "Text",
    DefaultValue = "",
    Count        = 1,
    UserPin      = true,
    PinStyle     = "Both"
  })
  
  -- Status Controls --
  table.insert(ctrls, {
    Name          = "Status",
    ControlType   = "Indicator",
    IndicatorType = Reflect and "StatusGP" or "Status",
    PinStyle      = "Output",
    UserPin       = true,
    Count         = 1
  })
  table.insert(ctrls, {
    Name         = "MachineNumber",
    ControlType  = "Text",
    PinStyle     = "Output",
    UserPin      = true,
    Count        = 1
  })
  table.insert(ctrls, {
    Name         = "ModelName",
    ControlType  = "Text",
    PinStyle     = "Output",
    UserPin      = true,
    Count        = 1
  })
  table.insert(ctrls, {
    Name         = "DeviceName",
    ControlType  = "Text",
    PinStyle     = "Output",
    UserPin      = true,
    Count        = 1
  })
  table.insert(ctrls, {
    Name         = "HostName",
    ControlType  = "Text",
    PinStyle     = "Output",
    UserPin      = true,
    Count        = 1
  })
  table.insert(ctrls, {
    Name         = "MACAddress",
    ControlType  = "Text",
    PinStyle     = "Output",
    UserPin      = true,
    Count        = 1,
    DefaultValue = ""
  })
  table.insert(ctrls, {
    Name         = "DeviceFirmware",
    ControlType  = "Text",
    PinStyle     = "Output",
    UserPin      = true,
    Count        = 1
  })
  table.insert(ctrls, {
    Name         = "SerialNumber",
    ControlType  = "Text",
    PinStyle     = "Output",
    UserPin      = true,
    Count        = 1
  })
  
  -- Switching Controls --
  
  table.insert(ctrls, {
    Name         = "AFV",
    ControlType  = "Button",
    ButtonType   = "Toggle",
    PinStyle     = "Both",
    UserPin      = true,
    Count        = 1
  })
  
  for i = 0, props['Output Count'].Value do
    for s = 1, props['Input Count'].Value do
      table.insert(ctrls, {
        Name = "vid-input_" .. s .. "-output_" .. i,
        ControlType = "Button",
        ButtonType = "Toggle",
        PinStyle = "Both",
        UserPin = true
      })
      table.insert(ctrls, {
        Name = "aud-input_" .. s .. "-output_" .. i,
        ControlType = "Button",
        ButtonType = "Toggle",
        PinStyle = "Both",
        UserPin = true
      })
    end
  end
  
  -- input Controls --
  --input levels are not specifically defined in protocol, however input level range is defined
  for i = 0, props['Input Count'].Value do
    table.insert(ctrls,{
      Name         = "input_" .. i .. "-level",
      ControlType  = "Knob",
      ControlUnit  = "Integer",
      DefaultValue = 0,
      Min          = -83,
      Max          = 24,
      Count        = 1,
      UserPin      = true,
      PinStyle     = "Both"
    })
    table.insert(ctrls, {
      Name         = "input_" .. i .. "-level_up",
      ControlType  = "Button",
      ButtonType   = "Momentary",
      Count        = 1,
      UserPin      = true,
      PinStyle     = "Input",
      Icon         = "Plus"
    })
    table.insert(ctrls, {
      Name         = "input_" .. i .. "-level_down",
      ControlType  = "Button",
      ButtonType   = "Momentary",
      Count        = 1,
      UserPin      = true,
      PinStyle     = "Input",
      Icon         = "Minus"
    })
    table.insert(ctrls, {
      Name         = "input_" .. i .. "-signal",
      ControlType  = "Indicator",
      IndicatorType= "Led",
      Count        = 1,
      UserPin      = true,
      PinStyle     = "Output"
    })
    table.insert(ctrls, {
      Name         = "vid-input_" .. i .. "-signal",
      ControlType  = "Indicator",
      IndicatorType= "Led",
      Count        = 1,
      UserPin      = true,
      PinStyle     = "Output"
    })
    table.insert(ctrls,{
      Name         = "input_" .. i .. "-name",
      ControlType  = "Text",
      DefaultValue = "Input " .. i,
      Count        = 1,
      UserPin      = true,
      PinStyle     = "Both"
    })
    end
  
  -- output Controls --
  for i = 0, props['Output Count'].Value do
    table.insert(ctrls,{
      Name 		= "output_" .. i .. "-level",
      ControlType  = "Knob",
      ControlUnit  = "Integer",
      DefaultValue = 0,
      Min          = -83,
      Max          = 24,
      Count        = 1,
      UserPin      = true,
      PinStyle     = "Both"
    })
    table.insert(ctrls, {
      Name         = "output_" .. i .. "-level_up",
      ControlType  = "Button",
      ButtonType   = "Trigger",
      Count        = 1,
      UserPin      = true,
      PinStyle     = "Input",
      Icon         = "Plus"
    })
    table.insert(ctrls, {
      Name         = "output_" .. i .. "-level_Down",
      ControlType  = "Button",
      ButtonType   = "Trigger",
      Count        = 1,
      UserPin      = true,
      PinStyle     = "Input",
      Icon         = "Minus"
    })
    table.insert(ctrls, {
      Name         = "output_" .. i .. "-mute",
      ControlType  = "Button",
      ButtonType   = "Toggle",
      Count        = 1,
      UserPin      = true,
      PinStyle     = "Both"
    })
    table.insert(ctrls, {
      Name         = "output_" .. i .. "-disable",
      ControlType  = "Button",
      ButtonType   = "Toggle",
      Count        = 1,
      UserPin      = true,
      PinStyle     = "Both"
    })
    table.insert(ctrls,{
      Name         = "output_" .. i .. "-name",
      ControlType  = "Text",
      DefaultValue = "Output " .. i,
      Count        = 1,
      UserPin      = true,
      PinStyle     = "Both"
    })
    table.insert(ctrls, {
      Name         = "output_" .. i .. "-source",
      ControlType  = "Text",
      Style        = "ComboBox",
      Count        = 1,
      UserPin      = true,
      PinStyle     = "Both"
    })
  end
  
  table.insert(ctrls, {
    Name         = "SendString",
    ControlType  = "Text",
    Count        = 1,
    DefaultValue = "#VID 1>2",
    UserPin      = true,
    PinStyle     = "Input"
  })
  table.insert(ctrls, {
    Name         = "ReceivedString",
    ControlType  = "Text",
    Count        = 1,
    UserPin      = true,
    PinStyle     = "Output"
  })
  table.insert(ctrls, {
    Name         = "LockFrontPanel",
    ControlType  = "Button",
    PinStyle     = "Both",
    ButtonType   = "Toggle",
    UserPin      = true,
    Count        = 1
  })
  return ctrls
end

--Layout of controls and graphics for the plugin UI to display
function GetControlLayout(props)
  local layout = {}
  local graphics = {}
  local CurrentPage = PageNames[props["page_index"].Value]
  	
  local colors = {  
    Background  = {232,232,232},
    Transparent = {255,255,255,0},
    Text        = {24,24,24},
    Header      = {0,0,0},
    Button      = {48,32,40},
    Red         = {217,32,32},
    DarkRed     = {80,16,16},
    Green       = {32,217,32},
    OKGreen     = {48,144,48},
    Blue        = {32,32,233},
    Black       = {0,0,0},
    White       = {255,255,255},
    Gray        = {96,96,96}
  }
  
  local function label(graphic)
    for k,v in pairs({
      Type = 'Label',
      Color = { 0, 0, 0 },
      HTextAlign = 'Right',
      FontSize = 14
    }) do graphic[k] = graphic[k] or v; end;
    table.insert(graphics, graphic);
  end;
  
  local function textinput(layout)
    for k,v in pairs({
      Color = { 208, 208, 208 },
      StrokeColor = { 102, 102, 102 },
      StrokeWidth = 2,
      CornerRadius = 8,
      FontSize = 12,
      Margin = 10,
      TextBoxStyle = 'Normal'
    }) do layout[k] = layout[k] or v; end;
    return layout;
    end;
  
  layout["code"]={PrettyName="code",Style="None"}  
      
  if(CurrentPage == 'Setup') then
    -- User defines connection properties
    table.insert(graphics,{Type="GroupBox",Text="Connect",Fill=colors.Background,StrokeWidth=1,CornerRadius=4,HTextAlign="Left",Position={5,5},Size={400,120}})
    if props["Connection Type"].Value=="Ethernet" then 
      table.insert(graphics,{Type="Text",Text="IP Address",Position={15,35},Size={100,16},FontSize=14,HTextAlign="Right"})
      layout["IPAddress"] = {PrettyName="Settings~IP Address",Style="Text",Color=colors.White,Position={120,35},Size={99,16},FontSize=12}
      table.insert(graphics,{Type="Text",Text="Port",Position={15,60},Size={100,16},FontSize=14,HTextAlign="Right"})
      layout["TcpPort"] = {PrettyName="Settings~Port",Style="Text",Position={120,60},Size={99,16},FontSize=12}
      table.insert(graphics,{Type="Text",Text="(5000 default)",Position={221,60},Size={100,18},FontSize=10,HTextAlign="Left"})
      --layout["Reboot"] = {PrettyName="Power~Reboot", Style="Button", Color=colors.Button, FontColor=colors.Red, FontSize=14, CornerRadius=2, Position={325,48}, Size={50,20} }
      --table.insert(graphics,{Type="Text",Text="Reboot",Position={315,35},Size={70,14},FontSize=12,HTextAlign="Center",Color=colors.Text})
    else
      table.insert(graphics,{Type="Text",Text="Reset Serial",Position={5,32},Size={110,16},FontSize=14,HTextAlign="Right"})
      layout["Reset"] = {PrettyName="Settings~Reset Serial", Style="Button", Color=colors.Button, FontColor=colors.Red, FontSize=14, CornerRadius=2, Position={120,30}, Size={50,20} }
      --table.insert(graphics,{Type="Text",Text="Reboot",Position={15,57},Size={100,16},FontSize=14,HTextAlign="Right"})
      --layout["Reboot"] = {PrettyName="Power~Reboot", Style="Button", Color=colors.Button, FontColor=colors.Red, FontSize=14, CornerRadius=2, Position={120,55}, Size={50,20} }
    end
    table.insert(graphics,{Type="Text",Text="Device ID",Position={15,85},Size={100,16},FontSize=14,HTextAlign="Right"})
    layout["DeviceID"] = {PrettyName="Settings~Device ID Number", Style="Text", FontColor=colors.Text, Position={120,85}, Size={99,16}, FontSize=12}
  
    -- Status fields updated upon connect show model/name/serial/sw rev
    table.insert(graphics,{Type="GroupBox",Text="Status",Fill=colors.Background,StrokeWidth=1,CornerRadius=4,HTextAlign="Left",Position={5,135},Size={400,220}})
    layout["Status"] = {PrettyName="Status~Connection Status", Position={40,165}, Size={330,32}, Padding=4 }
    table.insert(graphics,{Type="Text",Text="Device Name",Position={15,212},Size={100,16},FontSize=12,HTextAlign="Right"})
    layout["DeviceName"] = {PrettyName="Status~Device Name", Style="Text", HTextAlign="Left", IsReadOnly=true, Color=colors.Transparent, StrokeWidth=0, FontSize=14, IsBold=true, FontColor=colors.Text, Position={120,211}, Size={255,16} }
    table.insert(graphics,{Type="Text",Text="Model Name",Position={15,235},Size={100,16},FontSize=12,HTextAlign="Right"})
    layout["ModelName"] = {PrettyName="Status~Model Name", Style="Text", HTextAlign="Left", IsReadOnly=true, Color=colors.Transparent, StrokeWidth=0, FontSize=14, IsBold=true, FontColor=colors.Text, Position={120,234}, Size={255,16} }
    table.insert(graphics,{Type="Text",Text="Serial Number",Position={15,258},Size={100,16},FontSize=12,HTextAlign="Right"})
    layout["SerialNumber"] = {PrettyName="Status~Serial Number", Style="Text", HTextAlign="Left", IsReadOnly=true, Color=colors.Transparent, StrokeWidth=0, FontSize=14, IsBold=true, FontColor=colors.Text, Position={120,257}, Size={255,16} }
    table.insert(graphics,{Type="Text",Text="Software Version",Position={15,281},Size={100,16},FontSize=12,HTextAlign="Right"})
    layout["DeviceFirmware"] = {PrettyName="Status~SW Version", Style="Text", HTextAlign="Left", IsReadOnly=true, Color=colors.Transparent, StrokeWidth=0, FontSize=14, IsBold=true, FontColor=colors.Text, Position={120,280}, Size={255,16} }
    table.insert(graphics,{Type="Text",Text="MAC Address",Position={15,304},Size={100,16},FontSize=12,HTextAlign="Right"})
    layout["MACAddress"] = {PrettyName="Status~MAC Address", Style="Text", HTextAlign="Left", IsReadOnly=true, Color=colors.Transparent, StrokeWidth=0, FontSize=14, IsBold=true, FontColor=colors.Text, Position={120,303}, Size={255,16} }
  
    table.insert(graphics,{Type="Text",Text=GetPrettyName(),Position={15,200},Size={380,14},FontSize=10,HTextAlign="Right", Color=colors.Gray})
  
  elseif(CurrentPage == 'Utilities') then 
    
    table.insert(graphics,{Type="Text",Text="Audio follow video",         Position={  8,  4},Size={110, 16},FontSize=12,HTextAlign="Right"})
    layout["AFV"] = {PrettyName="Audio follow video",Style="Button",      Position={122,  4},Size={ 36, 16},FontSize=12,Color=colors.Red,Margin=0 }
    table.insert(graphics,{Type="Text",Text="Send string",                Position={  8, 24},Size={110, 16},FontSize=12,HTextAlign="Right"})
    layout["SendString"] = {PrettyName="Send string",Style="Text",        Position={122, 24},Size={110, 16},FontSize=12,Color=colors.White}
    table.insert(graphics,{Type="Text",Text="Received string",            Position={  8, 42},Size={110, 16},FontSize=12,HTextAlign="Right"})
    layout["ReceivedString"] = {PrettyName="Received string",Style="Text",Position={122, 42},Size={110, 16},FontSize=12,Color=colors.Gray}
    table.insert(graphics,{Type="Text",Text="Lock front panel",               Position={  8, 60},Size={110, 16},FontSize=12,HTextAlign="Right"})
    layout["LockFrontPanel"] = {PrettyName="Lock front panel",Style="Button", Position={122, 60},Size={ 36, 16},FontSize=12,Color=colors.Red,Margin=0 }
  
  elseif(CurrentPage == 'Matrix') then 
  
    --local helper = require("Helpers")
    helper = {}
    helper.Copy = function(tbl, seen)
      if type(tbl) ~= 'table' then return tbl end
      if seen and seen[tbl] then return seen[tbl] end
      local s = seen or {}
      local res = setmetatable({}, getmetatable(tbl))
      s[tbl] = res
      for k, v in pairs(tbl) do
          res[helper.Copy(k, s)] = helper.Copy(v, s)
      end
      if res==nil then print('Copy(): returning nil') end
      return res
    end  
  
    local large_matrix_size_ = { 12, 12 }
    -- create objects for each section so they can be modified easily
    -- add crosspoints (routes, labels, groupbox)
    local UI_crosspoints = {
      Position     = { 0, 8 },
      --Size        = { 0, 0 }, -- GroupBox contains Size of the whole object
      --buttons
      Padding     = { 4, 4 },
      GroupPadding= { 4, 4 },
      Button      = { Style = "Button", Size = { 36, 36}, Margin = 0 },
      AudioButton = { Style = "Button", Size = { 16, 12}, Margin = 0, FontSize=9, Color=colors.Red },
      NameText    = { Style = "Text", Type="Text", Color=colors.White, FontSize=10, HTextAlign="Center", WordWrap = true },
      NumButtons  = { props['Input Count'].Value, props['Output Count'].Value },
      Label       = { Style = "Label", Size = { 74, 14}, Type="Text", FontSize=10, HTextAlign="Center", WordWrap = true },
      Led         = { Style = "Led"  , Size = { 16, 16}, Margin=0, StrokeWidth=1, UnlinkOffColor=false },
      Outputs     = {}, -- to be filled in Init()
      AudioOutputs= {}, -- to be filled in Init()
      --groupbox
      GroupBox    = { Type="GroupBox", Text="", StrokeWidth=1, CornerRadius=4, HTextAlign="Left" },
      
      Init = function (self)
        if props['Input Count'].Value > large_matrix_size_[1] or props['Output Count'].Value > large_matrix_size_[2] then 
          self.Padding     = { 1, 1 }
          self.Button.Size = { 18, 18 }
          self.AudioButton.Size = { 8, 6 }
          self.Led.Size = { 8, 8 }
          --self.Label.Size = { 37, 7 }
        end
        self.GroupBox.Size = {
          self.Padding[1] + self.NumButtons[1]*(self.Padding[1] + self.Button.Size[1]),
          self.Padding[2] + self.NumButtons[2]*(self.Padding[2] + self.Button.Size[2]) + self.Label.Size[2]+ self.Padding[2] }
        self.GroupBox.Position  = self.Position        
        --local newPos_ = {}
        local z=0
        for i=1, self.NumButtons[1] do          
          for o=1, self.NumButtons[2] do
            z=z+1
            local btn_ = helper.Copy(self.Button)
            btn_['PrettyName'] = "Crosspoints~Output "..o.."~In" .. i .. " -> Out" .. o
            btn_['Legend'] = tostring(i)
            btn_['Position']={
              self.GroupBox.Position[1] + self.Padding[1] + (i-1)*(self.Button.Size[1] + self.Padding[1]), -- moving accross
              self.GroupBox.Position[2] + self.Padding[2] + (o-1)*(self.Button.Size[2] + self.Padding[2]) + self.Label.Size[2]+ self.Padding[2] } -- moving down
            btn_['ZOrder'] = z + 0x1000
            btn_.Layout_ID = "vid-input_" ..i.. "-output_" .. o
            if self.Outputs[o]==nil then self.Outputs[o]={} end
            self.Outputs[o][i]=btn_
  
            local aud_ = helper.Copy(self.AudioButton)
            aud_['PrettyName'] = "Crosspoints~Output "..o.."~In" .. i .. " -> Out" .. o .. " audio"
            --btn_['Legend'] = 'A'
            aud_['Position']={
              btn_.Position[1] + btn_.Size[1] - aud_.Size[1],
              btn_.Position[2] + btn_.Size[2] - aud_.Size[2] }
            btn_['ZOrder'] = z
            aud_.Layout_ID = "aud-input_" ..i.. "-output_" .. o
            if self.AudioOutputs[o]==nil then self.AudioOutputs[o]={} end
            self.AudioOutputs[o][i]=aud_
          end
        end
      end,
  
      Draw = function(self, layout)
        table.insert(graphics, self.GroupBox)
        for _,o in pairs(self.Outputs) do 
          for _,i in pairs(o) do layout[i.Layout_ID] = i end -- layout is the global layout
        end
        for _,o in pairs(self.AudioOutputs) do 
          for _,i in pairs(o) do layout[i.Layout_ID] = i end -- layout is the global layout
        end
      end,
  
      Move = function(self, distance)
        self.Position[1] = self.Position[1] + distance[1]
        self.Position[2] = self.Position[2] + distance[2]
        for _,o in pairs(self.Outputs) do 
          for _,i in pairs(o) do 
            i.Position[1] = i.Position[1] + distance[1]
            i.Position[2] = i.Position[2] + distance[2]
          end
        end
        for _,ao in pairs(self.AudioOutputs) do 
          for _,ai in pairs(ao) do 
            ai.Position[1] = ai.Position[1] + distance[1]
            ai.Position[2] = ai.Position[2] + distance[2]
          end
        end
      end
    }
  
    -- add outputs (names, locks)
    local UI_outputObjects = {
      --Position    = helper.Copy(UI_crosspoints.GroupBox.Position),
      Position    = helper.Copy(UI_crosspoints.Position),
      --buttons
      Padding     = helper.Copy(UI_crosspoints.Padding),
      NameText    = helper.Copy(UI_crosspoints.NameText), --Size = { 36, 54}      
      NumButtons  = props['Output Count'].Value,
      Buttons     = {}, -- to be filled in Init()
      Labels      = {}, -- to be filled in Init()
      --groupbox
      GroupBox    = helper.Copy(UI_crosspoints.GroupBox),
  
      Init = function(self)
        self.NameText.Size = { 76, UI_crosspoints.Button.Size[2] }
        self.LockButtons = {}
        -- GroupBox
        self.GroupBox.Size = {
          self.Padding[1], -- horiz, to be increased as buttons added
          UI_crosspoints.GroupBox.Size[2] } -- vert same as crosspoint GroupBox
        self.GroupBox.Position = self.Position
        self.GroupBox.Text="Outputs"
  
        local newPos_ = {}
  
        for o=1, self.NumButtons do
          newPos_ = {
            self.GroupBox.Position[1] + self.Padding[1], -- horiz always the same [output:0][input:0][horiz]
            UI_crosspoints.Outputs[o][1].Position[2] } -- vert moves down
          
            -- left column of labels (numbers only)
          local num_ = helper.Copy(UI_crosspoints.Label)
          num_.Size = { 18, UI_crosspoints.Button.Size[2] }
          num_["Text"] = tostring(o)
          num_['Position'] = helper.Copy(newPos_)
          table.insert(self.Labels, num_)
          newPos_[1] = newPos_[1] + num_.Size[1] + self.Padding[1]
          if o==1 then self.GroupBox.Size[1] = self.GroupBox.Size[1] + num_.Size[1] + self.Padding[1] end
  
          -- Names
          local name_ = helper.Copy(self.NameText)
          name_['PrettyName'] = "Outputs~".. o .."~name"
          name_['Position'] = helper.Copy(newPos_)
          name_.Layout_ID = "output_" .. o .. "-name"
          table.insert(self.Buttons, name_)
          newPos_[1] = newPos_[1] + name_.Size[1] + self.Padding[1]
          if o==1 then self.GroupBox.Size[1] = self.GroupBox.Size[1] + name_.Size[1] + self.Padding[1] end
        end
        -- set new position of UI_Crosspoints
        UI_crosspoints:Move({ newPos_[1] - UI_crosspoints.Outputs[1][1].Position[1] + self.Padding[1], 0})
        self.GroupBox.Size[1] = self.GroupBox.Size[1] + UI_crosspoints.GroupBox.Size[1]
      end,
  
      Draw = function(self, layout)
        table.insert(graphics, self.GroupBox)
        for _,l in ipairs(self.Labels ) do table.insert(graphics, l) end
        for _,b in ipairs(self.Buttons) do layout[b.Layout_ID] = b  end-- layout is the global layout
      end,
  
      Move = function(self, distance)
        self.Position[1] = self.Position[1] + distance[1]
        self.Position[2] = self.Position[2] + distance[2]
        for _,l in ipairs(self.Labels) do 
          l.Position[1] = l.Position[1] + distance[1]
          l.Position[2] = l.Position[2] + distance[2]
        end
        for _,b in pairs(self.Buttons) do 
          b.Position[1] = b.Position[1] + distance[1]
          b.Position[2] = b.Position[2] + distance[2]
        end
      end
    }
  
   -- add inputs (names)
    local UI_inputObjects = {
      Position    = {},
      --buttons
      Padding     = helper.Copy(UI_crosspoints.Padding),
      Button      = helper.Copy(UI_crosspoints.Button),
      Led         = helper.Copy(UI_crosspoints.Led),
      Label       = helper.Copy(UI_crosspoints.Label),
      NameText    = helper.Copy(UI_crosspoints.NameText),
      NumButtons  = props['Input Count'].Value,
      Nudge       = { Style = "Button", Size = {18,12}, Margin=0, Color=colors.Button, FontColor=colors.White, FontSize=9, CornerRadius=0 },
      Buttons     = {}, -- to be filled in Init()
      Labels      = {}, -- to be filled in Init()
      --groupbox
      GroupBox    = helper.Copy(UI_crosspoints.GroupBox),
  
      Init = function(self)
        self.NameText.Size = { UI_crosspoints.Button.Size[1], 54 }
        self.Label.HTextAlign = "Right"
        self.Position = helper.Copy(UI_crosspoints.GroupBox.Position)
        -- GroupBox   
        self.GroupBox.Size = {
          UI_crosspoints.GroupBox.Size[1], -- horiz, same as crosspoints
          UI_crosspoints.Label.Size[2] + self.Padding[2] + UI_crosspoints.Label.Size[2] + self.Padding[2] + UI_crosspoints.GroupBox.Size[2] + self.Padding[2] } -- vert, increase as objects added   
        self.GroupBox.Position = self.Position
        self.GroupBox.Text="Inputs"
  
        if props['Input Count'].Value > large_matrix_size_[1] or props['Output Count'].Value > large_matrix_size_[2] then 
          self.Padding     = {  1, 1 }
          self.Button.Size = { 18, 18 }
          self.Led.Size    = { 8, 8 }
        end
        local newPos_ = {}
  
        for i=1, self.NumButtons do
          newPos_ = {
            UI_crosspoints.Outputs[1][i].Position[1],
            self.Position[2] + self.Label.Size[2] + self.Padding[2] } -- vert always the same
          
          -- top row of labels (numbers only) above crosspoints
          local lbl_ = helper.Copy(UI_crosspoints.Label)
          lbl_.Size[1] = self.Button.Size[1]
          lbl_["Text"] = tostring(i)            
          lbl_['Position'] = helper.Copy(newPos_)
          table.insert(self.Labels, lbl_)
          newPos_[2] = lbl_.Position[2] + lbl_.Size[2] + self.Padding[2] + UI_crosspoints.GroupBox.Size[2] + self.Padding[2]
  
          -- below crosspoints
          -- Audio signal present
          local asignal_ = helper.Copy(self.Led)
          asignal_.Color=colors.Red
          asignal_['PrettyName'] = "Inputs~".. i .."~audio signal present"
          asignal_['Position'] = helper.Copy(newPos_)
          asignal_.Layout_ID = "input_" .. i .. "-signal"
          table.insert(self.Buttons, asignal_)
          --newPos_[2] = asignal_.Position[2] + asignal_.Size[2] + self.Padding[2]
          --if i==1 then self.GroupBox.Size[2] = self.GroupBox.Size[2] + asignal_.Size[2] + self.Padding[2] end
  
          -- Video signal present
          local vsignal_ = helper.Copy(self.Led)
          vsignal_.Color=colors.Green
          vsignal_['PrettyName'] = "Inputs~".. i .."~video signal present"
          vsignal_['Position'] = { 
            asignal_.Position[1] + asignal_.Size[1] + self.Padding[1],
            asignal_.Position[2] }
          if props['Input Count'].Value > large_matrix_size_[1] or props['Output Count'].Value > large_matrix_size_[2] then 
            vsignal_.Position[1] = asignal_.Position[1] + asignal_.Size[1]
          end
          vsignal_.Layout_ID = "vid-input_" .. i .. "-signal"
          table.insert(self.Buttons, vsignal_)
          if i==1 then 
            -- label to the left of the groupbox
            local lbl_signal_ = helper.Copy(self.Label)
            lbl_signal_["Text"] = "A/V Signal"            
            lbl_signal_['Position']={
              self.GroupBox.Position[1] - self.Padding[1] - lbl_signal_.Size[1], 
              newPos_[2] }
            lbl_signal_.Size[2] = vsignal_.Size[2]
            table.insert(self.Labels, lbl_signal_)
            self.GroupBox.Size[2] = self.GroupBox.Size[2] + vsignal_.Size[2] + self.Padding[2] 
          end
          newPos_[2] = vsignal_.Position[2] + vsignal_.Size[2] + self.Padding[2]
  
          if props['Model'].Value=='Other' then
              -- Gains
            local level_ = helper.Copy(self.Button)
            level_['PrettyName'] = "Inputs~".. i .."~level"
            level_['Position'] = helper.Copy(newPos_)
            level_['Style'] = "Fader"
            level_.ShowTextbox = true
            if props['Input Count'].Value > large_matrix_size_[1] or props['Output Count'].Value > large_matrix_size_[2] then 
              level_.Size[2] = 75
            else
              level_.Size[2] = 112
            end
            level_.Layout_ID = "input_" .. i .. "-level"
            table.insert(self.Buttons, level_)
            if i==1 then
              -- label to the left of the groupbox
              local lbl_level_ = helper.Copy(self.Label)
              lbl_level_["Text"] = "Gain"            
              lbl_level_['Position']={
                self.GroupBox.Position[1] - self.Padding[1] - lbl_level_.Size[1], 
                newPos_[2] }
                lbl_level_.Size[2] = level_.Size[2]
              table.insert(self.Labels, lbl_level_)
              self.GroupBox.Size[2] = self.GroupBox.Size[2] + level_.Size[2] + self.Padding[2]
            end
            newPos_[2] = level_.Position[2] + level_.Size[2]-- + self.Padding[2]
  
            --Gain dec
            local dec_ = helper.Copy(self.Nudge)
            dec_['PrettyName'] = "Inputs~".. i .."~down"
            dec_['Position'] = helper.Copy(newPos_)
            if props['Input Count'].Value > large_matrix_size_[1] or props['Output Count'].Value > large_matrix_size_[2] then 
              dec_.Position[2] = dec_.Position[2] + dec_.Size[2] 
            end
            dec_.Text = "-"
            dec_.String = "-=1"
            dec_.Layout_ID = "input_" .. i .. "-level_down"
            table.insert(self.Buttons, dec_)
            --newPos_[2] = dec_.Position[2] + dec_.Size[2] + self.Padding[2]
            --if i==1 then self.GroupBox.Size[2] = self.GroupBox.Size[2] + dec_.Size[2] + self.Padding[2] end
  
            --Gain inc
            local inc_ = helper.Copy(dec_)
            inc_['PrettyName'] = "Inputs~".. i .."~up"
            if props['Input Count'].Value > large_matrix_size_[1] or props['Output Count'].Value > large_matrix_size_[2] then 
              inc_.Position[2] = newPos_[2] 
            else
              inc_.Position[1] = dec_.Position[1] + dec_.Size[1]
            end
            inc_.Text = "+"
            inc_.String = "+=1"
            inc_.Layout_ID = "input_" .. i .. "-level_up"
            table.insert(self.Buttons, inc_)
            if i==1 then self.GroupBox.Size[2] = self.GroupBox.Size[2] + inc_.Size[2] + self.Padding[2] end
            if props['Input Count'].Value > large_matrix_size_[1] or props['Output Count'].Value > large_matrix_size_[2] then 
              newPos_[2] = dec_.Position[2] + dec_.Size[2] + self.Padding[2]
            else
              newPos_[2] = inc_.Position[2] + inc_.Size[2] + self.Padding[2]
            end
          end
  
          -- Names
          local name_ = helper.Copy(self.NameText)
          name_['PrettyName'] = "Inputs~".. i .."~name"
          name_['Position'] = helper.Copy(newPos_)
          name_.Layout_ID = "input_" .. i .. "-name"
          table.insert(self.Buttons, name_)
          if i==1 then
            -- label to the left of the groupbox
            local lbl_name_ = helper.Copy(self.Label)
            lbl_name_["Text"] = "Label"            
            lbl_name_['Position']={
              self.GroupBox.Position[1] - self.Padding[1] - lbl_name_.Size[1], 
              newPos_[2] }
            lbl_name_.Size[2] = name_.Size[2]
            table.insert(self.Labels, lbl_name_)
            self.GroupBox.Size[2] = self.GroupBox.Size[2] + name_.Size[2] + self.Padding[2]
          end
          newPos_[2] = name_.Position[2] + name_.Size[2] + self.Padding[2]
        end
        
        -- move other objects down
        UI_crosspoints:Move  ({0, UI_crosspoints.Label.Size[2] + self.Padding[2] + UI_crosspoints.Label.Size[2] + self.Padding[2] })
        UI_outputObjects:Move({0, UI_crosspoints.Label.Size[2] + self.Padding[2] + UI_crosspoints.Label.Size[2] + self.Padding[2] })
      end,
  
      Draw = function(self, layout)
        table.insert(graphics, self.GroupBox)
        for _,l in ipairs(self.Labels ) do table.insert(graphics, l) end
        for _,b in ipairs(self.Buttons) do  layout[b.Layout_ID] = b end -- layout is the global layout
      end,
  
      Move = function(self, distance)
        self.Position[1] = self.Position[1] + distance[1]
        self.Position[2] = self.Position[2] + distance[2]
        self.GroupBox.Position[1] = self.GroupBox.Position[1] + distance[1]
        self.GroupBox.Position[2] = self.GroupBox.Position[2] + distance[2]
        for _,l in ipairs(self.Labels) do 
          l.Position[1] = l.Position[1] + distance[1]
          l.Position[2] = l.Position[2] + distance[2]
        end
        for _,b in pairs(self.Buttons) do 
          b.Position[1] = b.Position[1] + distance[1]
          b.Position[2] = b.Position[2] + distance[2]
        end
      end
    }
  
    -- add post fade objects (source ComboBoxes)
    local UI_postFadeObjects = {
      Position    = helper.Copy(UI_crosspoints.Position),
      --buttons
      Button      = helper.Copy(UI_crosspoints.Button),
      Label       = helper.Copy(UI_crosspoints.Label),
      Padding     = helper.Copy(UI_crosspoints.Padding),
      Selector    = { Style = "ComboBox", Type="Text", Size={76, UI_crosspoints.Button.Size[2]}, Color=colors.White, FontSize=10, HTextAlign="Center", WordWrap = true },
      NumButtons  = props['Output Count'].Value,
      Buttons     = {}, -- to be filled in Init()
      Labels      = {}, -- to be filled in Init()
      --groupbox
      GroupBox    = helper.Copy(UI_crosspoints.GroupBox),
  
      Init = function(self)
        -- GroupBox
        self.GroupBox.Size = {
            self.Padding[1], -- horiz, to be increased as buttons added
            UI_crosspoints.Label.Size[2] + self.Padding[2] + UI_crosspoints.Label.Size[2] + self.Padding[2] + UI_crosspoints.GroupBox.Size[2] } -- vert, increase as objects added   
        self.GroupBox.Position = {
          UI_crosspoints.GroupBox.Position[1] + UI_crosspoints.GroupBox.Size[1] + self.Padding[1],
          UI_inputObjects.GroupBox.Position[2] }
        self.GroupBox.Text="Output"
        --self.Label.HTextAlign="Right"
        if props['Input Count'].Value > large_matrix_size_[1] or props['Output Count'].Value > large_matrix_size_[2] then 
          self.Padding = { 1, 1 }
          self.Button.Size = { 18, 18 }
          self.Selector.Size[2] = 18
          self.Label.FontSize = 6
        end
        local newPos_ = {}
  
        for o=1, self.NumButtons do
          local newPos_ = {
            self.GroupBox.Position[1] + self.Padding[1], 
            UI_crosspoints.Outputs[o][1].Position[2] }
          
          -- A/V Mutes
          local amute_ = helper.Copy(self.Button)
          amute_['Color'] = colors.Red
          if props['Input Count'].Value > large_matrix_size_[1] or props['Output Count'].Value > large_matrix_size_[2] then 
            amute_.Size[2] = 8
          else
            amute_.Size[2] = 16
          end
          amute_['PrettyName'] = "Outputs~".. o .."~mute"
          amute_['Position'] = helper.Copy(newPos_) 
          amute_.Layout_ID = "output_" .. o .. "-mute"
          table.insert(self.Buttons, amute_)
  
          local vmute_ = helper.Copy(amute_)
          vmute_.Color = colors.Green
          vmute_['PrettyName'] = "Outputs~".. o .."~disable"
          vmute_.Position[2] = amute_.Position[2] + amute_.Size[2] + self.Padding[2]
          vmute_.Layout_ID = "output_" .. o .. "-disable"
          table.insert(self.Buttons, vmute_)
  
          -- top row mutes label (text only) above crosspoints GroupBox
          if o==1 then
            local lbl_mute_ = helper.Copy(self.Label)
            lbl_mute_.Size = {
              self.Button.Size[1] + 2*self.Padding[1], -- need it wider so use up all the padding
              22 } 
            lbl_mute_["Text"] = "Aud/Vid Mute"            
            lbl_mute_['Position']={
              self.GroupBox.Position[1], -- horiz moves accross
              self.Position[2] + UI_crosspoints.Label.Size[2] } -- vert always the same
            table.insert(self.Labels, lbl_mute_)
  
            self.GroupBox.Size[1] = self.GroupBox.Size[1] + amute_.Size[1] + self.Padding[1]
          end
          newPos_[1] = newPos_[1] + amute_.Size[1] + self.Padding[1]
                 
          if props['Model'].Value=='Other' then
            -- Gain knob
            local gain_ = helper.Copy(self.Button)
            gain_['PrettyName'] = "Outputs~".. o .."~level"
            gain_['Style'] = "Knob"
            gain_['Position'] = helper.Copy(newPos_)
            gain_.Layout_ID = "output_" .. o .. "-level"
            table.insert(self.Buttons, gain_)
  
            -- top row gain knob label (text only) above crosspoints GroupBox
            if o==1 then
              local lbl_gain_ = helper.Copy(self.Label)
              lbl_gain_.Size[1] = self.Button.Size[1]
              lbl_gain_["Text"] = "Gain"            
              lbl_gain_['Position']={
                newPos_[1], -- horiz moves accross
                self.Position[2] + UI_crosspoints.Label.Size[2] + self.Padding[2] } -- vert always the same
              table.insert(self.Labels, lbl_gain_)
              self.GroupBox.Size[1] = self.GroupBox.Size[1] + gain_.Size[1] + self.Padding[1]
            end
            newPos_[1] = newPos_[1] + gain_.Size[1] + self.Padding[1]
          end
          
          -- source select ComboBox
          local selector_ = helper.Copy(self.Selector)
          selector_['PrettyName'] = "Outputs~".. o .."~source"
          selector_['Position']= helper.Copy(newPos_)
          selector_.Layout_ID = "output_" .. o .. "-source"
          table.insert(self.Buttons, selector_)
  
          -- top row selector label (text only) above crosspoints GroupBox
          if o==1 then
            local lbl_selector_ = helper.Copy(self.Label)
            lbl_selector_.Size[1] = selector_.Size[1]
            lbl_selector_["Text"] = "Input select"            
            lbl_selector_['Position']={
              newPos_[1], -- horiz moves accross
              self.Position[2] + UI_crosspoints.Label.Size[2] + self.Padding[2] } -- vert always the same
            table.insert(self.Labels, lbl_selector_)
            self.GroupBox.Size[1] = self.GroupBox.Size[1] + selector_.Size[1] + self.Padding[1]
          end
          newPos_[1] = newPos_[1] + selector_.Size[1] + self.Padding[1]
  
        end
  
        UI_outputObjects.GroupBox.Size[1] = UI_outputObjects.GroupBox.Size[1] + self.Padding[1] + self.GroupBox.Size[1]
      end,
  
      Draw = function(self, layout)
        table.insert(graphics, self.GroupBox)
        for _,l in ipairs(self.Labels ) do table.insert(graphics, l) end
        for _,b in ipairs(self.Buttons) do layout[b.Layout_ID] = b  end-- layout is the global layout
      end,
  
      Move = function(self, distance)
        self.Position[1] = self.Position[1] + distance[1]
        self.Position[2] = self.Position[2] + distance[2]
        for _,l in ipairs(self.Labels) do 
          l.Position[1] = l.Position[1] + distance[1]
          l.Position[2] = l.Position[2] + distance[2]
        end
        for _,b in pairs(self.Buttons) do 
          b.Position[1] = b.Position[1] + distance[1]
          b.Position[2] = b.Position[2] + distance[2]
        end
      end
    }
  
    UI_crosspoints:Init() -- initialize the crosspoints so other components can reference it's positions
    UI_outputObjects:Init() -- this also moves crosspoints to the right
    UI_inputObjects:Init() -- this also moves crosspoints down
    UI_postFadeObjects:Init() -- this also expands output GroupBox to the right
    
    UI_crosspoints:Draw(layout)
    UI_outputObjects:Draw(layout)
    UI_inputObjects:Draw(layout)
    UI_postFadeObjects:Draw(layout)
  
  end
  return layout, graphics
end

--Start event based logic
if Controls then
  -- Q-Sys plugin for Kramer Protocol 3000
  -- <https://github.com/rod-driscoll/q-sys-plugin-kramer-protocol-3000>
  -- 20231106 v1.0.0 Rod Driscoll<rod@theavitgroup.com.au>
  
  if Controls then
    
  	local helper = require('helpers')
  
  	-- Control aliases
  	Status = Controls.Status
  	
  	local SimulateFeedback = System.IsEmulating
  	-- Variables and flags
  	DebugTx=false
  	DebugRx=false
  	DebugFunction=false
  	DebugPrint=Properties["Debug Print"].Value	
  
  	-- Timers, tables, and constants
  	StatusState = { OK = 0, COMPROMISED = 1, FAULT = 2, NOTPRESENT = 3, MISSING = 4, INITIALIZING = 5 }
  	Heartbeat = Timer.New()
  	VolumeDebounce = Timer.New()
  	PollRate = Properties["Poll Interval"].Value
  	Timeout = PollRate + 10
  	BufferLength = 1024
  	ConnectionType = Properties["Connection Type"].Value
  	DataBuffer = ""
  	CommandQueue = {}
  	CommandProcessing = false
  	--Internal command timeout
  	CommandTimeout = 5
  	CommunicationTimer = Timer.New()
  	TimeoutCount = 0
  
  	--Hide controls that are just for pins
  	--Controls["ModelNumber"].IsInvisible=true
  	--Controls["PanelType"].IsInvisible=true
  
  
  		local Request = {
  			Status			={Command="",			Data=""},
  			AudioEmbedding	={Command="AUD-EMB",	Data=""},
  			AudioFollowVideo	={Command="AFV",	Data=""},
  			AudioLevel		={Command="AUD-LVL",	Data=""},
  			AudioRoute	={Command="AUD",Data=""}, -- Legacy
  			AudioLevelRange	={Command="AUD-LVL-RANGE",Data=""},
  			AudioSignalPresent={Command="AUD-SIGNAL",Data=""},
  			AutoSwitchMode	={Command="AV-SW-MODE",	Data=""},
  			AutoSwitchTimeout={Command="AV-SW-TIMEOUT",Data=""},
  			AvRoute   ={Command="AV",Data=""},
  			DeviceInfo		={Command="BEACON-INFO",Data=""},
  			BuildDate		={Command="BUILD-DATE",	Data=""},
  			CopyEDIDSet		={Command="CPEDID",		Data=""},
  			HPD				={Command="DISPLAY",	Data=""},
  			DipSwitch		={Command="DPSW-STATUS",Data=""},
  			EthernetPort	={Command="ETH-PORT",	Data=""},
  			Error			={Command="ERR",		Data=""},
  			FactoryReset	={Command="FACTORY",	Data=""},
  			FPGAVersion		={Command="FPGA-VER",	Data=""},
  			HDCPMode		={Command="HDCP-MOD",	Data=""},
  			HDCPStatus		={Command="HDCP-STAT",	Data=""},
  			Help			={Command="HELP",		Data=""},
  			Label		={Command="LABEL",	Data=""},
  			LockEDID		={Command="LOCK-EDID",	Data=""},
  			LockFrontPanel		={Command="LOCK-FP",	Data=""},
  			Login			={Command="LOGIN",		Data=""},
  			Logout			={Command="LOGOUT",		Data=""},
  			Model			={Command="MODEL",		Data=""},
  			Mute			={Command="MUTE",		Data=""},
  			HostName		={Command="NAME",		Data=""},
  			ResetName		={Command="NAME-RST",	Data=""},
  			NetworkConfig	={Command="NET-CONFIG",	Data=""},
  			DHCP			={Command="NET-DHCP",	Data=""},
  			Gateway			={Command="NET-GATE",	Data=""},
  			IPAddress		={Command="NET-IP",		Data=""},
  			MACAddress		={Command="NET-MAC",	Data=""},
  			NetMask			={Command="NET-MASK",	Data=""},
  			Password		={Command="PASS",		Data=""},
  			ProtocolVersion	={Command="PROT-VER",	Data=""},
  			PresetList	={Command="PRST-LST",	Data=""},
  			PresetRecall	={Command="PRST-RCL",	Data=""},
  			PresetStore	={Command="PRST-STO",	Data=""},
  			Reset			={Command="RESET",		Data=""},
  			Route			={Command="ROUTE",		Data=""}, -- Legacy
  			Security		={Command="SECUR",		Data=""},
  			SignalPresent	={Command="SIGNAL",		Data=""},
  			SerialNumber	={Command="SN",			Data=""},
  			Time			={Command="TIME",		Data=""},
  			TestPattern	={Command="VID-PATTERN",		Data=""},
  			TimeZone		={Command="TIME-LOC",	Data=""},
  			TimeServer		={Command="TIME-SRV",	Data=""},
  			DeviceFirmware	={Command="VERSION",	Data=""},
  			VGAPhase		={Command="VGA-PHASE",	Data=""},
  			VideoMute		={Command="VMUTE",		Data=""},
  			VideoRoute   ={Command="VID",Data=""}, -- Legacy
  	}
  
  	-- Helper functions
  	-- A function to determine common print statement scenarios for troubleshooting
  	function SetupDebugPrint()
  		if DebugPrint=="Tx/Rx" then
  			DebugTx,DebugRx=true,true
  		elseif DebugPrint=="Tx" then
  			DebugTx=true
  		elseif DebugPrint=="Rx" then
  			DebugRx=true
  		elseif DebugPrint=="Function Calls" then
  			DebugFunction=true
  		elseif DebugPrint=="All" then
  			DebugTx,DebugRx,DebugFunction=true,true,true
  		end
  	end
  
  	-- A function to clear controls/flags/variables and clears tables
  	function ClearVariables()
  		if DebugFunction then print("ClearVariables() Called") end
  		Controls["SerialNumber"].String = ""
  		Controls["DeviceFirmware"].String = ""
  		Controls["ModelName"].String = ""
  		Controls["DeviceName"].String = ""
  		Controls["MACAddress"].String = ""
  		DataBuffer = ""
  		CommandQueue = {}
  	end
  
  	--Reset any of the "Unavailable" data;  Will cause a momentary colision that will resolve itself the customer names the device "Unavailable"
  	function ClearUnavailableData()
  		if DebugFunction then print("ClearUnavailableData() Called") end
  		-- If data was unavailable reset it; the next poll loop will test for it again
  		for i,ctrl in ipairs({ "SerialNumber", "DeviceFirmware", "ModelNumber", "ModelName", "DeviceName", "MACAddress" }) do
  			if(Controls[ctrl].String == "Unavailable")then
  				Controls[ctrl].String = ""
  			end
  		end
  	end
  
  	-- Update the Status control
  	function ReportStatus(state,msg)
  		if DebugFunction then print("ReportStatus() Called: "..state.." - "..msg) end
  		local msg=msg or ""
  		Status.Value=StatusState[state]
  		Status.String=msg
  	end
  
  	
  	function Split(s, delimiter)
  		if DebugFunction then print("Split() Called") end
  		local result = {};
  		for match in (s..delimiter):gmatch("(.-)"..delimiter) do
  			table.insert(result, match);
  		end
  		return result;
  	end
  	
  	--Parse a string from byte array
  	function ParseString(data)
  		if DebugFunction then print("ParseString() Called") end
  		local name = ""
  		for i,byte in ipairs(data) do
  			name = name .. string.char(byte)
  		end
  		return name
  	end
  
  	function GetPrintableHexString(str)
  		local result_ = ""
  		for i=1, #str do
  			local c = str:sub(i,i)
  			if c:byte() > 0x1F and c:byte() < 0x7F then
  				result_ = result_..c
  			else
  				result_ = result_..string.format("\\x%02X", c:byte())
  			end
  		end
  		return result_  
  	end
  
  	--A debounce timer on power up avoids reporting the TCP reset that occurs as ane error
  	function ClearDebounce()
  		PowerOnDebounce = false
  	end
  	-------------------------------------------------------------------------------
  	-- Device functions
  	-------------------------------------------------------------------------------
  
  	function Connected()
  		if DebugFunction then print("Connected() Called") end
  		CommunicationTimer:Stop()
  		Heartbeat:Start(PollRate)
  		CommandProcessing = false
  		QueryRoutes()
  		SendNextCommand()
  		end
  
  
  	--[[  Communication format
  		All commands are hex bytes of the format:
  		Header   CommandName   Constant   Parameters   Suffix
  			#     <Command>       0x20    <Data>  0x0d
  
  		Both Serial and TCP mode must contain functions:
  		Connect()
  		And a receive handler that passes data to ParseData()
  	]]
  	
  	-- Take a request object and queue it for sending.  Object format is of:
  	--  { Command=string, Data={string} }
  	function Send(cmd, sendImmediately)
  		if DebugFunction then print("DoSend() Called") end
  		local value = "#".. cmd.Command .. " " .. cmd.Data .. 0x0d
  	
  		--Check for if a command is already queued
  		for i, val in ipairs(CommandQueue) do
  			if(val == value)then
  				--Some Commands should be sent immediately
  				if sendImmediately then
  					--remove other copies of a command and move to head of the queue
  					table.remove(CommandQueue,i)
  					if DebugTx then print("Sending: "..GetPrintableHexString(value)) end
  					table.insert(CommandQueue,1,value)
  				end
  				return
  			end
  		end
  		--Queue the command if it wasn't found
  		table.insert(CommandQueue,value)
  		SendNextCommand()
  	end
  
  	--Timeout functionality
  	-- Close the current and start a new connection with the next command
  	-- This was included due to behaviour within the Comms Serial; may be redundant check on TCP mode
  	CommunicationTimer.EventHandler = function()
  		if DebugFunction then print("CommunicationTimer Event (timeout) Called") end
  		ReportStatus("MISSING","Communication Timeout")
  		CommunicationTimer:Stop()
  		CommandProcessing = false
  		SendNextCommand()
  	end 
  
  		--  Serial mode Command function  --
  	if ConnectionType == "Serial" then
  		print("Serial Mode Initializing...")
  		-- Create Serial Connection
  		Comms = SerialPorts[1]
  		Baudrate, DataBits, Parity = 9600, 8, "N"
  
  		--Send the display the next command off the top of the queue
  		function SendNextCommand()
  		if DebugFunction then print("SendNextCommand() Called") end
  		if CommandProcessing then
  			-- Do Nothing
  		elseif #CommandQueue > 0 then
  			CommandProcessing = true
  			if DebugTx then print("Sending: "..GetPrintableHexString(CommandQueue[1])) end
  			Comms:Write( table.remove(CommandQueue,1) )
  			CommunicationTimer:Start(CommandTimeout)
  		else
  			CommunicationTimer:Stop()
  		end
  		end
  
  		function Disconnected()
  			if DebugFunction then print("Disconnected() Called") end
  			CommunicationTimer:Stop() 
  			CommandQueue = {}
  			Heartbeat:Stop()
  		end
  		
  			-- Clear old and open the socket, sending the next queued command
  		function Connect()
  			if DebugFunction then print("Connect() Called") end
  			Comms:Close()
  			Comms:Open(Baudrate, DataBits, Parity)
  		end
  
  		-- Handle events from the serial port
  		Comms.Connected = function(serialTable)
  			if DebugFunction then print("Connected handler called Called") end
  			ReportStatus("OK","")
  			Connected()
  		end
  		
  		Comms.Reconnect = function(serialTable)
  			if DebugFunction then print("Reconnect handler called Called") end
  			Connected()
  		end
  		
  		Comms.Data = function(serialTable, data)
  			ReportStatus("OK","")
  			CommunicationTimer:Stop() 
  			CommandProcessing = false
  			local msg = DataBuffer .. Comms:Read(1024)
  			DataBuffer = "" 
  			if DebugTx then print("Received: "..GetPrintableHexString(msg)) end
  			ParseResponse(msg)
  			SendNextCommand()
  		end
  		
  		Comms.Closed = function(serialTable)
  			if DebugFunction then print("Closed handler called Called") end
  			Disconnected()
  			ReportStatus("MISSING","Connection closed")
  		end
  		
  		Comms.Error = function(serialTable, error)
  			if DebugFunction then print("Socket Error handler called Called") end
  			Disconnected()
  			ReportStatus("MISSING",error)
  		end
  		
  		Comms.Timeout = function(serialTable, error)
  			if DebugFunction then print("Socket Timeout handler called Called") end
  			Disconnected()
  			ReportStatus("MISSING","Serial Timeout")
  		end
  
  		--[[
  		Controls["Reset"].EventHandler = function()
  			if DebugFunction then print("Reset handler called Called") end
  			PowerupTimer:Stop()
  			ClearVariables()
  			Disconnected()
  			Connect()
  		end
  		]]
  		
  		--  Ethernet Command Function  --
  	else
  		print("TCP Mode Initializing...")
  		IPAddress = Controls.IPAddress
  			Port = Controls.Port
  		-- Create Sockets
  		Comms = TcpSocket.New()
  		Comms.ReconnectTimeout = 5
  		Comms.ReadTimeout = 10  --Tested to verify 6 seconds necessary for input switches;  Appears some TV behave mroe slowly
  		Comms.WriteTimeout = 10
  
  		--Send the display the next command off the top of the queue
  		function SendNextCommand()
  			if DebugFunction then print("SendNextCommand() Called") end
  			if CommandProcessing then
  			-- Do Nothing
  			elseif #CommandQueue > 0 then
  				if not Comms.IsConnected then
  					Connect()
  				else
  					CommandProcessing = true
  					if DebugTx then print("Sending: "..GetPrintableHexString(CommandQueue[1])) end
  					Comms:Write( table.remove(CommandQueue,1) )
  				end
  			end
  			end
  		
  		function Disconnected()
  			if DebugFunction then print("Disconnected() Called") end
  			if Comms.IsConnected then
  				Comms:Disconnect()
  			end
  			CommandQueue = {}
  			Heartbeat:Stop()
  		end
  		
  		-- Clear old and open the socket
  		function Connect()
  			if DebugFunction then print("Connect() Called") end
  			if IPAddress.String ~= "Enter an IP Address" and IPAddress.String ~= "" and Port.String ~= "" then
  			if Comms.IsConnected then
  				Comms:Disconnect()
  			end
  			Comms:Connect(IPAddress.String, tonumber(Port.String))
  			else
  			ReportStatus("MISSING","No IP Address or Port")
  			end
  		end
  			
  		-- Handle events from the socket;  Nearly identical to Serial
  		Comms.EventHandler = function(sock, evt, err)
  			if DebugFunction then print("Ethernet Socket Handler Called") end
  			if evt == TcpSocket.Events.Connected then
  			ReportStatus("OK","")
  			Connected()
  			elseif evt == TcpSocket.Events.Reconnect then
  			--Disconnected()
  		
  			elseif evt == TcpSocket.Events.Data then
  			ReportStatus("OK","")
  			CommandProcessing = false
  			TimeoutCount = 0
  			local line = sock:Read(BufferLength)
  			local msg = DataBuffer
  			DataBuffer = "" 
  			while (line ~= nil) do
  				msg = msg..line
  				line = sock:Read(BufferLength)
  			end
  			if DebugTx then print("Received: "..GetPrintableHexString(msg)) end
  			ParseResponse(msg)  
  			SendNextCommand()
  			
  			elseif evt == TcpSocket.Events.Closed then
  			Disconnected()
  			ReportStatus("MISSING","Socket closed")
  		
  			elseif evt == TcpSocket.Events.Error then
  			Disconnected()
  			ReportStatus("MISSING","Socket error")
  		
  			elseif evt == TcpSocket.Events.Timeout then
  			TimeoutCount = TimeoutCount + 1
  			if TimeoutCount > 3 then
  				Disconnected()
  				ReportStatus("MISSING","Socket Timeout")
  			end
  		
  			else
  			Disconnected()
  			ReportStatus("MISSING",err)
  		
  			end
  		end
  	
  		--Ethernet specific event handlers
  		Controls["IPAddress"].EventHandler = function()
  			if DebugFunction then print("IP Address Event Handler Called") end
  			if Controls["IPAddress"].String == "" then
  			Controls["IPAddress"].String = "Enter an IP Address"
  			end
  			ClearVariables()
  			Init()
  		end
  
  		Controls["TcpPort"].EventHandler = function()
  			if DebugFunction then print("Port Event Handler Called") end
  			ClearVariables()
  			Init()
  		end
  
  		Controls["DeviceID"].EventHandler = function()
  			if DebugFunction then print("DeviceID Event Handler Called") end
  			ClearVariables()
  			Init()
  		end
  
  	end
  
  	function Query(cmd)
  		Send({
  			Command = cmd.Command .. "?",
  			Data = cmd.Data
  		})
  	end
  
  	function PrintError(msg)
  		local codes_ = {
  			[0] = 'P3K_NO_ERROR',
  			[1] = 'ERR_PROTOCOL_SYNTAX',
  			[2] = 'ERR_COMMAND_NOT_AVAILABLE',
  			[3] = 'ERR_PARAMETER_OUT_OF_RANGE',
  			[4] = 'ERR_UNAUTHORIZED_ACCESS',
  			[5] = 'ERR_INTERNAL_FW_ERROR',
  			[6] = 'ERR_BUSY',
  			[7] = 'ERR_WRONG_CRC',
  			[8] = 'ERR_TIMEDOUT',
  			[9] = 'ERR_RESERVED',
  			[10] = 'ERR_FW_NOT_ENOUGH_SPACE',
  			[11] = 'ERR_FS_NOT_ENOUGH_SPACE',
  			[12] = 'ERR_FS_FILE_NOT_EXISTS',
  			[13] = 'ERR_FS_FILE_CANT_CREATED',
  			[14] = 'ERR_FS_FILE_CANT_OPEN',
  			[15] = 'ERR_FEATURE_NOT_SUPPORTED',
  			[16] = 'ERR_RESERVED_2',
  			[17] = 'ERR_RESERVED_3',
  			[18] = 'ERR_RESERVED_4',
  			[19] = 'ERR_RESERVED_5',
  			[20] = 'ERR_RESERVED_6',
  			[21] = 'ERR_PACKET_CRC',
  			[22] = 'ERR_PACKET_MISSED',
  			[23] = 'ERR_PACKET_SIZE',
  			[24] = 'ERR_RESERVED_7',
  			[25] = 'ERR_RESERVED_8',
  			[26] = 'ERR_RESERVED_9',
  			[27] = 'ERR_RESERVED_10',
  			[28] = 'ERR_RESERVED_11',
  			[29] = 'ERR_RESERVED_12',
  			[30] = 'ERR_EDID_CORRUPTED',
  			[31] = 'ERR_NON_LISTED',
  			[32] = 'ERR_SAME_CRC',
  			[33] = 'ERR_WRONG_MODE',
  			[34] = 'ERR_NOT_CONFIGURED'
  		}
  		if codes_[tonumber(msg)]~=nil then
  			if DebugFunction then print('ERROR: '..codes_[tonumber(msg)]) end
  		end
  	end
  
  	function SetRouteFeedback(layer, output, input)
  		if DebugFunction then print("SetRouteFeedback(layer: "..layer..", output: "..output..", index: "..input..")") end
  		--if DebugFunction then print('Handling Route: "'..msg["Data"]..'"') end
  		if output~=nil and input~=nil then
  			local in_ = tonumber(input)
  			local out_ = tonumber(output)
  			if out_~=nil and out_ <= Properties['Output Count'].Value and in_~=nil and in_ <= Properties['Input Count'].Value then
  				for i=1, Properties['Input Count'].Value do
  					if layer==Layers.Video then
  						Controls["vid-input_"..i.."-output_" ..output].Boolean = (in_==i) 
  					elseif layer==Layers.Audio then    
  						Controls["aud-input_"..i.."-output_" ..output].Boolean = (in_==i) 
  					end   
  				end
  			end
  		end
  	end
  
  	--  Device Request and Data handlers
  	
  	--[[ Test the device once for
  		Model Number
  		Device Name
  		Model Name
  		Serial Number
  		SW Revision
  	]]
  	-- Initial data grab from device
  	function GetDeviceInfo()
  		if DebugFunction then print("GetDeviceInfo() Called") end
  		if Properties["Get Device Info"].Value then
  			Query( Request["DeviceInfo"] ) -- gets "IPAddress", "UDPPort", "TCPPort", "MACAddress", "Model", and "DeviceName" 
  			if(Controls["SerialNumber"].String == "") then Query( Request["SerialNumber"] )  end
  			if(Controls["DeviceFirmware"].String == "") then Query( Request["DeviceFirmware"] )  end
  		end
  		Query( Request["AudioFollowVideo"] )
  		QueryLabels()
  		if Properties['Model'].Value=='Other' then QueryLevelRanges() end
  	end
  	
  	function QueryLabels()
  		if DebugFunction then print("QueryLabels())") end
  		for i=1, Properties['Input Count'].Value do
  			local cmd_ = {Command = Request["Label"].Command, Data = '0,'..i }
  			if SimulateFeedback then ParseResponse(string.format("~%02X@%s %s\x0d\x0a", Controls['DeviceID'].Value, cmd_.Command, cmd_.Data..',Input '..i)) end
  			Query(cmd_)
  		end
  		for o=1, Properties['Output Count'].Value do
  			local cmd_ = {Command = Request["Label"].Command, Data = '1,'..o }
  			if SimulateFeedback then ParseResponse(string.format("~%02X@%s %s\x0d\x0a", Controls['DeviceID'].Value, cmd_.Command, cmd_.Data..',Output '..o)) end
  			Query(cmd_)
  		end
  	end
  
  	function QueryLevelRanges()
  		if DebugFunction then print("QueryLevelRanges())") end
  		for i=1, Properties['Input Count'].Value do
  			local cmd_ = {Command = Request["AudioLevelRange"].Command, Data = '0,'..i }
  			if SimulateFeedback then ParseResponse(string.format("~%02X@%s %s\x0d\x0a", Controls['DeviceID'].Value, cmd_.Command, cmd_.Data..',-83,24')) end
  			Query(cmd_)
  		end
  		for o=1, Properties['Output Count'].Value do
  			local cmd_ = {Command = Request["AudioLevelRange"].Command, Data = '1,'..o }
  			if SimulateFeedback then ParseResponse(string.format("~%02X@%s %s\x0d\x0a", Controls['DeviceID'].Value, cmd_.Command, cmd_.Data..',-83,24')) end
  			Query(cmd_)
  		end
  	end
  
  	local function QueryRoutes()
  		Query({Command = Request["Route"].Command, Data = Layers.Video ..',*'})
  		Query({Command = Request["Route"].Command, Data = Layers.Audio ..',*'})
  	end
  
  	--[[  Response Data parser
  		
  		All response commands are hex bytes of the format
  		Header    DeviceID   Constant   CommandName  Parameters   Suffix
  			~      nn      		@  		<Command>    <Parameter>  0x0d0x0a
  	
  		Read until a header is found, then:
  		1. Define a data object
  		2. Parse the command, DeviceID, and ack into the structure
  		3. Parse the data into an array
  		4. Push the data object into a handler based on the command
  	
  		Recursively call if there is more data after the suffix. Stuff incomplete messages in the buffer
  	]]
  	function ParseResponse(msg)
  		if DebugFunction then print("ParseResponse() Called") end
  		Controls["ReceivedString"].String = msg
  		local delimPos_ = msg:find("\x0d\x0a")
  		local valid_ = msg:len()>0 and delimPos_~=nil
  		--Message is too short, buffer the chunk and wait for more
  		if not valid_ then 
  			print("invalid: "..msg)
  			DataBuffer = DataBuffer .. msg
  			--Message doesn't start at begining.  Find the correct start then parse from there
  		elseif msg:byte(1) ~= string.byte('~') then
  			local i=msg:find('~') 
  			if i ~= nil then
  				ParseResponse( msg:sub(i,-1) )
  			else
  				DataBuffer = DataBuffer .. msg
  			end
  		else
  			--Pack the data for the handler
  			local m1_,m2_,m3_ = msg:match('~([^@]+)@([^ ]*) ([^\x0d]+)\x0d\x0a')
  			local ResponseObj = { ['DeviceID']=m1_, ['Command']=m2_, ['Data']=m3_ }
  			if DebugFunction then print('DeviceID: '..m1_..', Command: "'..m2_..'", data: "'..m3_..'"') end
  			--if DebugFunction then print('cResponseObj[DeviceID]:'..ResponseObj['DeviceID']) end
  			
  			if ResponseObj['Command']:len()==0 and ResponseObj['Data']:lower() == 'ok' then
  				if DebugFunction then print('device id set: '..ResponseObj['DeviceID']) end
  				Controls['DeviceID'].Value = tonumber(ResponseObj['DeviceID'])
  			elseif Controls['DeviceID'].Value == nil then
  				if DebugFunction then print('ResponseObj[DeviceID]:'..tonumber(ResponseObj['DeviceID'])) end
  				Controls['DeviceID'].Value = tonumber(ResponseObj['DeviceID'])
  				if DebugFunction then print('device id is nil, set to "'..tostring(Controls['DeviceID'].Value)..'"') end
  			end  
  			
  			if Controls['DeviceID'].Value == tonumber(ResponseObj['DeviceID']) then
  				--if DebugFunction then print('device id "'..tostring(Controls['DeviceID'].Value)..'" matches') end
  				HandleResponse(ResponseObj)    
  			else
  				if DebugFunction then print('device id "'..ResponseObj['DeviceID']..'" does not match "'..tostring(Controls['DeviceID'].Value)..'"') end
  			end
  
  			--Re-process any remaining data
  			if delimPos_~=nil and (delimPos_+2 < msg:len()) then
  				ParseResponse( msg:sub(delimPos_+2,-1) )
  			end
  			end
  	end
  	
  	-- Handler for good data from interface
  	function HandleResponse(msg)
  		if DebugFunction then print('HandleResponse('..msg.Command..') Called, data: "'..msg.Data..'"') end
  		
  		local vals_ = {}
  		for g in string.gmatch(msg["Data"], "[^,]+") do
  			table.insert(vals_, g)
  		end
  
  		local io_ = { ['0'] = 'Input', ['1'] = 'Output'}
  
  		--Beacon info
  		if msg.Command==Request["DeviceInfo"].Command then
  			if DebugFunction then 
  				if vals_[1]~=nil then print("port_id: "..vals_[1]) end
  				if vals_[2]~=nil then print("IPAddress: "..vals_[2]) end
  				if vals_[3]~=nil then print("udp_port: "..vals_[3]) end
  				if vals_[4]~=nil then print("tcp_port: "..vals_[4]) end
  				if vals_[5]~=nil then print("MACAddress: "..vals_[5]) end
  				if vals_[6]~=nil then print("ModelName: "..vals_[6]) end
  				if vals_[7]~=nil then print("DeviceName: "..vals_[7]) end
  			end
  			if vals_[2]~=nil then Controls["IPAddress"].String = vals_[2] end
  			if vals_[4]~=nil then Controls["Port"].String = vals_[4] end
  			if vals_[5]~=nil then Controls["MACAddress"].String = vals_[5] end
  			if vals_[6]~=nil then Controls["ModelName"].String = vals_[6] end
  			if vals_[7]~=nil then Controls["DeviceName"].String = vals_[7] end
  
  		--Hostname
  		elseif msg.Command==Request["HostName"].Command then
  			if DebugFunction then print("HostName: "..msg["Data"]) end
  			Controls["HostName"].String = msg["Data"]
  		--Firmware
  		elseif msg.Command==Request["DeviceFirmware"].Command then
  			if DebugFunction then print("DeviceFirmware: "..msg["Data"]) end
  			Controls["DeviceFirmware"].String = msg["Data"]
  		--SW Version
  		elseif msg.Command==Request["SerialNumber"].Command then
  			if DebugFunction then print("SerialNumber: "..msg["Data"]) end
  			Controls["SerialNumber"].String = msg["Data"]
  
  		elseif msg.Command==Request["IPAddress"].Command then
  			if DebugFunction then print("IPAddress: "..msg["Data"]) end
  			Controls["IPAddress"].String = msg["Data"]
  			
  		elseif msg.Command==Request["MACAddress"].Command then
  			if DebugFunction then print("MACAddress: "..msg["Data"]) end
  			Controls["MACAddress"].String = msg["Data"]
  
  		elseif msg.Command==Request["EthernetPort"].Command then
  			if DebugFunction then print("EthernetPort: "..msg["Data"]) end
  			Controls["Port"].String = msg["Data"]
  			
  		elseif msg.Command==Request["Model"].Command then
  			if DebugFunction then print("ModelName: "..msg["Data"]) end
  			Controls["ModelName"].String = msg["Data"]
  
  
  		elseif msg.Command==Request["BuildDate"].Command then
  			if DebugFunction then print("BuildDate: "..msg["Data"]) end
  			
  		elseif msg.Command==Request["DipSwitch"].Command then
  			if DebugFunction then print("DipSwitch: "..msg["Data"]) end
  
  		elseif msg.Command==Request["FPGAVersion"].Command then
  			if DebugFunction then print("FPGAVersion: "..msg["Data"]) end
  
  		elseif msg.Command==Request["NetworkConfig"].Command then
  			if DebugFunction then print("NetworkConfig: "..msg["Data"]) end
  			if DebugFunction then 
  				if vals_[1]~=nil then print("NetworkAdaptor: "..vals_[1]) end 
  				if vals_[2]~=nil then print("IPAddress: "..vals_[2])  end
  				if vals_[3]~=nil then print("SubnetMask: "..vals_[3]) end
  				if vals_[4]~=nil then print("Gateway: "..vals_[4]) end
  				if vals_[5]~=nil then print("dns1: "..vals_[5]) end
  				if vals_[6]~=nil then print("dns2: "..vals_[6]) end
  			end
  			if vals_[2]~=nil then Controls["IPAddress"].String = vals_[2] end
  
  		elseif msg.Command==Request["DHCP"].Command then
  			if DebugFunction then print("DHCP: "..msg["Data"]) end
  			
  		elseif msg.Command==Request["Gateway"].Command then
  			if DebugFunction then print("Gateway: "..msg["Data"]) end
  			
  		elseif msg.Command==Request["NetMask"].Command then
  			if DebugFunction then print("SubnetMask: "..msg["Data"]) end
  			
  		elseif msg.Command==Request["ProtocolVersion"].Command then
  			if DebugFunction then print("ProtocolVersion: "..msg["Data"]) end
  			
  		elseif msg.Command==Request["Time"].Command then
  			if DebugFunction then print("Time: "..msg["Data"]) end
  			
  		elseif msg.Command==Request["TimeZone"].Command then
  			if DebugFunction then print("TimeZone: "..msg["Data"]) end
  			
  		elseif msg.Command==Request["TimeServer"].Command then
  			if DebugFunction then print("TimeServer: "..msg["Data"]) end
  
  		elseif msg.Command==Request["Error"].Command then
  			if DebugFunction then print("Error: "..msg["Data"]) end
  			PrintError(msg["Data"])
  
  		--Authentication
  		elseif msg.Command==Request["Login"].Command then
  			if DebugFunction then print("Username: "..msg["Data"]) end
  			Controls["Username"].String = msg["Data"]	
  
  		elseif msg.Command==Request["Password"].Command then
  			--if DebugFunction then print("Password: "..msg["Data"]) end
  			if DebugFunction then 
  				if vals_[1]~=nil then print("login_level: "..vals_[1]) end
  				if vals_[2]~=nil then print("password: "..vals_[2]) end
  			end
  			if vals_[1]~=nil then Controls["Username"].String = vals_[1] end
  			if vals_[2]~=nil then Controls["Password"].String = vals_[2] end
  
  		elseif msg.Command==Request["Security"].Command then
  			if DebugFunction then print("Security: "..msg["Data"]) end
  			--Controls["Security"].String = msg["Data"]	
  
  		elseif msg.Command==Request["Logout"].Command then
  			if DebugFunction then print("Logout: "..msg["Data"]) end
  			--if msg["Data"]:lower()=='ok'
  		
  		elseif msg.Command==Request["Label"].Command then
  			if DebugFunction then print("Label: "..msg["Data"]) end
  			local io_ = vals_[1]=='0' and 'in' or 'out'
  			Controls[io_ .. "put_" .. vals_[2] .. "-name"].String = vals_[3]
  
  		--Audio
  		elseif msg.Command==Request["AudioEmbedding"].Command then
  			if DebugFunction then print("Embed: "..msg["Data"]) end
  
  		elseif msg.Command==Request["AudioLevelRange"].Command then
  			if DebugFunction then print("AudioLevelRange: "..msg["Data"]) end
  			if #vals_>3 then
  				if DebugFunction then print(io_[vals_[1]]..": "..vals_[2].." min: "..vals_[3].." max: "..vals_[4]) end
  				--helper.PrintControl(Controls["input_"..vals_[2].."-level"])
  				if vals_[1] == '0' and tonumber(vals_[2]) <= Properties['Input Count'].Value then
  					Inputs = Inputs or {}
  					Inputs[tonumber(vals_[2])] = Inputs[tonumber(vals_[2])] or {}
  					Inputs[tonumber(vals_[2])].MinValue = tonumber(vals_[3])
  					Inputs[tonumber(vals_[2])].MaxValue = tonumber(vals_[4])
  					--print("[input_"..vals_[2].."-level].MinValue: "..Controls["input_"..vals_[2].."-level"].MinValue)
  					--print("[input_"..vals_[2].."-level].MaxValue: "..Controls["input_"..vals_[2].."-level"].MaxValue)
  					--Controls["input_"..vals_[2].."-level"].MaxValue = tonumber(vals_[4])
  				elseif vals_[1] == '1' and tonumber(vals_[2]) <= Properties['Output Count'].Value then
  					Outputs = Outputs or {}
  					Outputs[tonumber(vals_[2])] = Outputs[tonumber(vals_[2])] or {}
  					Outputs[tonumber(vals_[2])].MinValue = tonumber(vals_[3])
  					Outputs[tonumber(vals_[2])].MaxValue = tonumber(vals_[4])
  					--Controls["output_"..vals_[2].."-level"].MinValue = tonumber(vals_[3])
  					--Controls["output_"..vals_[2].."-level"].MaxValue = tonumber(vals_[4])
  				end
  			end
  
  		elseif msg.Command==Request["AutoSwitchMode"].Command then
  			if DebugFunction then print("AutoSwitchMode: "..msg["Data"]) end
  
  		elseif msg.Command==Request["AutoSwitchTimeout"].Command then
  			if DebugFunction then print("AutoSwitchTimeout: "..msg["Data"]) end
  			
  		elseif msg.Command==Request["Mute"].Command then
  			if DebugFunction then print("Mute: "..msg["Data"]) end
  			if DebugFunction and #vals_>2 then 
  				print("output: "..vals_[1].." mute: "..vals_[2]) 
  			end
  			if #vals_>1 and tonumber(vals_[1]) <= Properties['Output Count'].Value then
  				Controls["output_"..vals_[1].."-mute"].Boolean = (vals_[2]=="1") 
  			end
  			
  		elseif msg.Command==Request["AudioSignalPresent"].Command then
  			if DebugFunction then print("AudioSignalPresent: "..msg["Data"]) end
  			if DebugFunction and #vals_>1 then 
  				print("aud-input_"..vals_[1].."-signal: "..vals_[2]) 
  			end
  			if #vals_>1 and tonumber(vals_[1]) <= Properties['Output Count'].Value then
  				--Controls["input_"..vals_[1].."-signal"].Boolean = (vals_[2]=='1')
  				Controls["input_"..vals_[1].."-signal"].Boolean = true
  			end
  			
  		elseif msg.Command==Request["AudioLevel"].Command then
  			if DebugFunction then print("AudioLevel: "..msg["Data"]) end
  			local layerName_ = vals_[1]=="0" and "input" or "output"
  			if DebugFunction and #vals_>2 then 
  				print(layerName_.."_"..vals_[2].."-level: "..vals_[3]) 
  			end
  			if #vals_>2 then
  				Controls[layerName_.."_"..vals_[2].."-level"].Value = tonumber(vals_[3]) 
  			end
  
  		elseif msg.Command==Request["AudioFollowVideo"].Command then
  			if DebugFunction then print("AudioFollowVideo: "..msg["Data"]) end
  			Controls["AFV"].Boolean = (msg.Data=='1')
  			for o = 0, Properties['Output Count'].Value do
  				for i = 1, Properties['Input Count'].Value do
  					Controls["aud-input_" .. i .. "-output_" .. o].IsInvisible = (msg.Data=='1')
  				end
  			end
  
  		--Video
  		elseif msg.Command==Request["SignalPresent"].Command then
  			if DebugFunction then print("SignalPresent: "..msg["Data"]) end
  			if DebugFunction and #vals_>1 then 
  				print("vid-input_"..vals_[1].."-signal: "..vals_[2]) 
  			end
  			if #vals_>1 and tonumber(vals_[1]) <= Properties['Output Count'].Value then
  				Controls["vid-input_"..vals_[1].."-signal"].Boolean = (vals_[2]=='1') 
  			end
  
  		elseif msg.Command==Request["HPD"].Command then
  			if DebugFunction then print("HPD: "..msg["Data"]) end
  
  		elseif msg.Command==Request["HDCPMode"].Command then
  			if DebugFunction then print("HDCPMode: "..msg["Data"]) end
  
  		elseif msg.Command==Request["HDCPStatus"].Command then
  			if DebugFunction then print("HDCPStatus: "..msg["Data"]) end
  
  		elseif msg.Command==Request["LockEDID"].Command then
  			if DebugFunction then print("LockEDID: "..msg["Data"]) end
  
  		elseif msg.Command==Request["VGAPhase"].Command then
  			if DebugFunction then print("VGAPhase: "..msg["Data"]) end
  
  		elseif msg.Command==Request["VideoMute"].Command then
  			if DebugFunction then print("VideoMute: "..msg["Data"]) end
  			if DebugFunction and #vals_>2 then 
  				print("output: "..vals_[1].." video mute: "..vals_[2]) 
  			end
  			if #vals_>1 and tonumber(vals_[1]) <= Properties['Output Count'].Value then
  				Controls["output_"..vals_[1].."-disable"].Boolean = (vals_[2]~="1") --0:disabled, 1:enabled, 2:blank(not all models)
  			end
  
  		elseif msg.Command==Request["Route"].Command then -- "ROUTE 1,2,3"
  			SetRouteFeedback(vals_[1], vals_[2], vals_[3])
  
  		elseif msg.Command==Request["AvRoute"].Command then 
  			local in_, out_ = string.match(msg["Data"], "(%d+)>(%d+)") -- "AV 1>2"
  			SetRouteFeedback(Layers.Video, out_, in_)
  			SetRouteFeedback(Layers.Audio, out_, in_)
  
  		elseif msg.Command==Request["VideoRoute"].Command then
  			local in_, out_ = string.match(msg["Data"], "(%d+)>(%d+)") -- "VID 1>2"
  			SetRouteFeedback(Layers.Video, out_, in_)
  
  		elseif msg.Command==Request["AudioRoute"].Command then
  			local in_, out_ = string.match(msg["Data"], "(%d+)>(%d+)") -- "AUD 1>2"
  			SetRouteFeedback(Layers.Audio, out_, in_)
  
  		else
  				print("Response not handled")
  		end
  	end
  	-------------------------------------------------------------------------------
  	-- Device routing functions
  	-------------------------------------------------------------------------------
  	local function SetAvRoute(dest, src, state) -- "AV 1>2"
  		if(state == 0) then
  			if DebugFunction then print("Disconnecting src "..src.." from "..dest) end
  			src = 0
  		else
  			if DebugFunction then print("Send src " .. src .. " to dest " .. dest) end
  		end
  		if dest == 0 then dest = '*' end -- all
  		local cmd_ = Request["VideoRoute"]
  		cmd_.Data = src..'>'.. dest
  		Send(cmd_)
  		if SimulateFeedback then ParseResponse(string.format("~%02X@%s %s\x0d\x0a", Controls['DeviceID'].Value, cmd_.Command, cmd_.Data)) end
  	end
  	
  	local function SetRoute(layer, dest, src, state) -- "ROUTE 0,1,2"
  		if(state == 0) then
  			if DebugFunction then print("Disconnecting layer " .. layer .. " src "..src.." from "..dest) end
  			 src = 0
  		 else
  			if DebugFunction then print("Send layer " .. layer .. " from src " .. src .. " to dest " .. dest) end
  		end
  		if dest == 0 then dest = '*' end
  		local cmd_ = Request["Route"]
  		cmd_.Data = layer ..','..dest..','.. src
  		Send(cmd_)
  		if SimulateFeedback then ParseResponse(string.format("~%02X@%s %s\x0d\x0a", Controls['DeviceID'].Value, cmd_.Command, cmd_.Data)) end
  	end
  
  	local function SetAudRoute(dest, src, state) -- "AUD 1>2"
  		if(state == 0) then
  			dest = "x"
  			if DebugFunction then print("Disconnecting audio src from all") end
  		else
  			if DebugFunction then print("Send audio src " .. src .. " to dest " .. dest) end
  		end
  		if dest == 0 then dest = '*' end
  		local cmd_ = Request["AudioRoute"]
  		cmd_.Data = src..'>'.. dest
  		Send(cmd_)
  		if SimulateFeedback then ParseResponse(string.format("~%02X@%s %s\x0d\x0a", Controls['DeviceID'].Value, cmd_.Command, cmd_.Data)) end
  	end
  
  	local function SetAudioFollowVideo(state)
  		if DebugFunction then print("Send Audio follow video: "..tostring(state)) end
  		local cmd_ = Request["AudioFollowVideo"]
  		cmd_.Data = state and "1" or "0"
  		Send(cmd_)
  		if SimulateFeedback then ParseResponse(string.format("~%02X@%s %s\x0d\x0a", Controls['DeviceID'].Value, cmd_.Command, cmd_.Data)) end
  	end
  	 
  	local function SetFrontPanelLock(state)
  		if DebugFunction then print("Lock front panel: "..tostring(state)) end
  		local cmd_ = Request["LockFrontPanel"]
  		cmd_.Data = state and "1" or "0"
  		Send(cmd_)
  		if SimulateFeedback then ParseResponse(string.format("~%02X@%s %s\x0d\x0a", Controls['DeviceID'].Value, cmd_.Command, cmd_.Data)) end
  	end
  
  	local function SetInputLevel(index, value)
  		if DebugFunction then print("Set input " .. index .. " level to " .. value) end
  		local cmd_ = Request["AudioLevel"]
  		local value_ = tonumber(value)==nil and value or math.floor(value)
  		cmd_.Data = '0' ..','..index..','.. value
  		Send(cmd_)
  		--if SimulateFeedback and tonumber(value)~=nil then ParseResponse(string.format("~%02X@%s %s\x0d\x0a", Controls['DeviceID'].Value, cmd_.Command, cmd_.Data)) end
  	end
  
  	local function SetOutputLevel(index, value)
  		if DebugFunction then print("Set output " .. index .. " level to " .. value) end
  		local cmd_ = Request["AudioLevel"]
  		cmd_.Data = '1' ..','..index..','.. math.floor(value)
  		Send(cmd_)
  		--if SimulateFeedback and tonumber(value)~=nil then ParseResponse(string.format("~%02X@%s %s\x0d\x0a", Controls['DeviceID'].Value, cmd_.Command, cmd_.Data)) end
  	end
  	
  	local function SetOutputMute(index, value)
  		if DebugFunction then print("Set output " .. index .. " mute to " .. tostring(value)) end
  		local cmd_ = Request["Mute"]
  		cmd_.Data = index..','.. (value and '1' or '0')
  		Send(cmd_)
  		--if SimulateFeedback then ParseResponse(string.format("~%02X@%s %s\x0d\x0a", Controls['DeviceID'].Value, cmd_.Command, cmd_.Data)) end
  	end
  
  	local function SetOutputDisable(index, value)
  		if DebugFunction then print("Set output " .. index .. " video mute to " .. tostring(value)) end
  		local cmd_ = Request["VideoMute"]
  		cmd_.Data = index..','.. (value and '0' or '1') -- 0:disabled, 1:enabled, 2:blank(not all models)
  
  		Send(cmd_)
  		--if SimulateFeedback then ParseResponse(string.format("~%02X@%s %s\x0d\x0a", Controls['DeviceID'].Value, cmd_.Command, cmd_.Data)) end
  	end
  
  	local function SetOutputLabel(index, value)
  		if DebugFunction then print("Set output " .. index .. " label to " .. value) end
  		local cmd_ = Request["Label"]
  		cmd_.Data = '1,'.. index .. ',' .. value
  		--cmd_.Data = '1,'.. index .. ',1,' .. value -- the extra 1 is for enable custom label
  		Send(cmd_)
  		--if SimulateFeedback then ParseResponse(string.format("~%02X@%s %s\x0d\x0a", Controls['DeviceID'].Value, cmd_.Command, cmd_.Data)) end
  	end
  
  	local function SetInputLabel(index, value)
  		if DebugFunction then print("Set output " .. index .. " label to " .. value) end
  		local cmd_ = Request["Label"]
  		cmd_.Data = '0,'.. index .. ',' .. value
  		--cmd_.Data = '0,'.. index .. ',1,' .. value -- the extra 1 is for enable custom label
  		Send(cmd_)
  		--if SimulateFeedback then ParseResponse(string.format("~%02X@%s %s\x0d\x0a", Controls['DeviceID'].Value, cmd_.Command, cmd_.Data)) end
  	end
  	
  	-------------------------------------------------------------------------------
  	-- Initialize
  	-------------------------------------------------------------------------------	
  	function TestFeedbacks()
  		local cmd_ = Request["SignalPresent"]
  		cmd_.Data = '1,1'
  		ParseResponse(string.format("~%02X@%s %s\x0d\x0a", Controls['DeviceID'].Value, cmd_.Command, cmd_.Data))
  
  		cmd_ = Request["AudioSignalPresent"]
  		cmd_.Data = '2,1'
  		ParseResponse(string.format("~%02X@%s %s\x0d\x0a", Controls['DeviceID'].Value, cmd_.Command, cmd_.Data))
  		
  		cmd_ = Request["AudioFollowVideo"]
  		cmd_.Data = '1'
  		ParseResponse(string.format("~%02X@%s %s\x0d\x0a", Controls['DeviceID'].Value, cmd_.Command, cmd_.Data))
  
  		cmd_ = Request["AudioFollowVideo"]
  		cmd_.Data = '1'
  		ParseResponse(string.format("~%02X@%s %s\x0d\x0a", Controls['DeviceID'].Value, cmd_.Command, cmd_.Data))
  --[[
  		cmd_ = Request["Label"]
  		for i = 1, Properties['Input Count'].Value do
  			cmd_.Data = '0,'..tostring(i)..',INPUT '..i
  			ParseResponse(string.format("~%02X@%s %s\x0d\x0a", Controls['DeviceID'].Value, cmd_.Command, cmd_.Data))
  		end 
  		for o = 1, Properties['Output Count'].Value do
  			cmd_.Data = '1,'..tostring(o)..',OUTPUT '..o
  			ParseResponse(string.format("~%02X@%s %s\x0d\x0a", Controls['DeviceID'].Value, cmd_.Command, cmd_.Data))
  		end 
  --]]
  	end
  
  	function Initialize()
  		if DebugFunction then print("Initialize() Called: "..GetPrettyName()) end
  		--helper.TablePrint(Controls, 1)
  		Layers = { Video = 1, Audio = 2, Data  = 3, IR = 4, USB = 5 }
  
  		-- EventHandlers
  		Controls["AFV"].EventHandler = function(ctl) 
  			if DebugFunction then print("Audio follow video pressed") end
  			SetAudioFollowVideo(ctl.Boolean)
  		end
  
  		Controls["SendString"].EventHandler = function(ctl) 
  			if DebugFunction then print("SendString called: "..ctl.String) end
  			local value = ctl.String .. 0x0d
  			if value:sub(1,1)~='#' then value = '#' .. value end
  			if DebugTx then print('Sending['..value:len()..']: '..GetPrintableHexString(value)) end
  			table.insert(CommandQueue,value)
  			SendNextCommand()
  			if SimulateFeedback then ParseResponse(string.format("~%02X@%s\x0d\x0a", Controls['DeviceID'].Value, ctl.String:gsub('#',''))) end
  		end
  
  		Controls["LockFrontPanel"].EventHandler = function(ctl) 
  			if DebugFunction then print("Lock front panel pressed") end
  			SetFrontPanelLock(ctl.Boolean)
  		end
  
  		--helper.TablePrint(Properties, 1)
  		if(Properties['Output Count'].Value > 0 and Properties['Input Count'].Value > 0) then
  			for o = 0, Properties['Output Count'].Value do
  				for i = 1, Properties['Input Count'].Value do
  					-- Crosspoint EventHandlers
  					Controls["vid-input_" .. i .. "-output_" .. o].EventHandler = function(ctl) 
  						if DebugFunction then print("vid-input_" .. i .. "-output_" .. o .. " pressed") end
  						--SetRoute(Layers.Video, o, i, ctl.Value)
  						SetAvRoute(o, i, ctl.Value)
  						if(o == 0) then ctl.Value = 0 end -- let the individual output buttons track state
  					end
  					Controls["aud-input_" .. i .. "-output_" .. o].EventHandler = function(ctl) 
  						if DebugFunction then print("vid-input_" .. i .. "-output_" .. o .. " pressed") end
  						--SetRoute(Layers.Audio, o, i, ctl.Value)
  						SetAudRoute(o, i, ctl.Value)
  					end
  				end
  				
  				-- Output EventHandlers
  				Controls["output_".. o .."-mute"].EventHandler = function(ctl)
  					if DebugFunction then print("output_".. o .."-mute pressed, Value: "..tostring(ctl.Value>0)) end
  					if o>0 then SetOutputMute(o, (ctl.Value>0)) end
  				end
  
  				Controls["output_".. o .."-disable"].EventHandler = function(ctl)
  					if DebugFunction then print("output_".. o .."-disable pressed, Value: "..tostring(ctl.Value>0)) end
  					if o>0 then SetOutputDisable(o, (ctl.Value>0)) end
  				end
  
  				Controls["output_".. o .."-level"].EventHandler = function(ctl)
  					if DebugFunction then print("output_".. o .."-level pressed, Value: "..ctl.Value) end
  					if o>0 then SetOutputLevel(o, ctl.Value) end
  				end
  
  				Controls["output_".. o .."-name"].EventHandler = function(ctl)
  					if DebugFunction then print("output_".. o .."-name changed, Value: "..ctl.String) end
  					SetOutputLabel(o, ctl.String)
  				end
  				
  			end
  			
  			-- Input EventHandlers
  			for i = 1, Properties['Input Count'].Value do
  
  				Controls["input_".. i .."-level"].EventHandler = function(ctl)
  					if DebugFunction then print("input_".. i .."-level pressed, Value: "..ctl.Value) end
  					Controls["input_".. i .."-level"].RampTime = 0
  					SetInputLevel(i, ctl.Value)
  				end
  
  				Controls["input_".. i .."-level_up"].EventHandler = function(ctl)
  					local state_ = ctl.Boolean and "pressed" or "released"
  					if DebugFunction then print("input_".. i .."-level_up "..state_..", MaxValue: "..Controls["input_".. i .."-level"].MaxValue) end
  					if ctl.Boolean then
  						SetInputLevel(i, "++")
  						Controls["input_".. i .."-level"].RampTime = 5
  						Controls["input_".. i .."-level"].Value = Inputs[i].MaxValue
  						--SetInputLevel(i, Inputs[i].MaxValue)
  					else
  						Controls["input_".. i .."-level"].RampTime = 0
  						Controls["input_".. i .."-level"].Value = Controls["input_".. i .."-level"].Value -- need to do this or the ramp won't stopy
  						SetInputLevel(i, Controls["input_".. i .."-level"].Value)
  						--SetInputLevel(i, Controls["input_".. i .."-level"].Value)
  					end
  				end
  
  				Controls["input_".. i .."-level_down"].EventHandler = function(ctl)
  					local state_ = ctl.Boolean and "pressed" or "released"
  					if DebugFunction then print("input_".. i .."-level_down "..state_) end
  					if ctl.Boolean then
  						SetInputLevel(i, "--")
  						Controls["input_".. i .."-level"].RampTime = 5
  						Controls["input_".. i .."-level"].Value = Inputs[i].MinValue
  						--SetInputLevel(i, Controls["input_".. i .."-level"].MinValue)
  						--SetInputLevel(i, Inputs[i].MinValue)
  					else
  						Controls["input_".. i .."-level"].RampTime = 0
  						Controls["input_".. i .."-level"].Value = Controls["input_".. i .."-level"].Value -- need to do this or the ramp won't stopy
  						SetInputLevel(i, Controls["input_".. i .."-level"].Value)
  						--SetInputLevel(i, Controls["input_".. i .."-level"].Value)
  					end
  				end
  
  				Controls["input_".. i .."-name"].EventHandler = function(ctl)
  					if DebugFunction then print("input_".. i .."-name changed, Value: "..ctl.String) end
  					SetInputLabel(i, ctl.String)
  				end
  
  			end
  		end
  
  		Disconnected()
  		Connect()
  		GetDeviceInfo()
  		if System.IsEmulating then TestFeedbacks() end
  		
  		Heartbeat:Start(PollRate)
  	end
  
  	-- Timer EventHandlers  --
  	Heartbeat.EventHandler = function()
  		if DebugFunction then print("Heartbeat Event Handler Called - CommandQueue size: "..#CommandQueue) end
  		if #CommandQueue < 1 then
  			for i = 1, Properties['Input Count'].Value do
  				Query({ Command=Request["SignalPresent"].Command, Data='1,'..tostring(i) })
  				Query({ Command=Request["AudioSignalPresent"].Command, Data='1,'..tostring(i) })
  			end
  		end
  	end
  
  	SetupDebugPrint()
  	Initialize()
  end
end
